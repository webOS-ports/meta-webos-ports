From e77de090727f4efa1991579576300e08e7787434 Mon Sep 17 00:00:00 2001
From: "piyush10.asalmol" <piyush10.asalmol@lge.com>
Date: Tue, 8 Nov 2022 17:59:24 +0530
Subject: [PATCH] Fix for peer Device List Info issue

:Release Notes:
Fix for peer device list info issue

:Detailed Notes:
Fix for peer device list info issue

:Testing Performed:
Tested locally

:QA Notes:
NA

:Issues Addressed:
[WRO-15182] [OSE-RPi4] : peer device info is not listing in terminal

Change-Id: Ibaac4172dd71007babf9165c7ebb122d27684bdd
Reviewed-on: http://gpro.lge.com/c/webosose/connman-webos/+/338999
Reviewed-by: Commit Msg Checker <commit_msg@lge.com>
Reviewed-by: <muralidhar.n@lge.com>
Tested-by: <muralidhar.n@lge.com>
---
 gsupplicant/supplicant.c | 102 +++++++++++++++++++++++++++++++++++++--
 plugins/wifi.c           |  54 ++++++++++++---------
 2 files changed, 129 insertions(+), 27 deletions(-)

diff --git a/gsupplicant/supplicant.c b/gsupplicant/supplicant.c
index cc0a16e9..411cf5ae 100644
--- a/gsupplicant/supplicant.c
+++ b/gsupplicant/supplicant.c
@@ -2484,8 +2484,7 @@ static void bss_compute_security(struct g_supplicant_bss *bss)
 	if (bss->keymgmt &
 			(G_SUPPLICANT_KEYMGMT_WPA_PSK |
 				G_SUPPLICANT_KEYMGMT_WPA_FT_PSK |
-				G_SUPPLICANT_KEYMGMT_WPA_PSK_256 |
-				G_SUPPLICANT_KEYMGMT_SAE))
+				G_SUPPLICANT_KEYMGMT_WPA_PSK_256))
 		bss->psk = TRUE;
 
 	if (bss->ieee8021x)
@@ -3090,6 +3089,12 @@ static GSupplicantInterface *interface_alloc(const char *path)
 	interface->bss_mapping = g_hash_table_new_full(g_str_hash, g_str_equal,
 								NULL, NULL);
 
+	interface->p2p_peer_path_to_network = g_hash_table_new_full(g_str_hash, g_str_equal,
+								NULL, NULL);
+
+	interface->p2p_group_path_to_group = g_hash_table_new_full(g_str_hash, g_str_equal,
+								NULL, NULL);
+
 	g_hash_table_replace(interface_table, interface->path, interface);
 
 	return interface;
@@ -5532,7 +5537,7 @@ static void extract_peer_with_ip(const char *path, DBusMessageIter *iter, connma
 
 static void signal_group_peer_joined(const char *path, DBusMessageIter *iter)
 {
-	const char *peer_path = NULL;
+	//const char *peer_path = NULL;
 	extract_peer_with_ip(path, iter, TRUE, false);
 }
 static gboolean peer_joined_with_ip(gpointer data)
@@ -8648,6 +8653,46 @@ static void interface_p2p_reject_params(DBusMessageIter *iter, void *user_data)
 	dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH,
 							&data->peer->path);
 }
+
+int g_supplicant_interface_p2p_reject(GSupplicantInterface *interface,
+					GSupplicantPeerParams *peer_params,
+					GSupplicantInterfaceCallback callback,
+					void *user_data)
+{
+	struct interface_reject_data* data;
+	int ret;
+
+	SUPPLICANT_DBG("");
+
+	if (!interface || !peer_params || !peer_params->path)
+		return -EINVAL;
+
+	if (!interface->p2p_support)
+		return -ENOTSUP;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (!data)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->path = g_strdup(interface->path);
+	data->peer = peer_params;
+	data->callback = callback;
+	data->user_data = user_data;
+
+	ret = supplicant_dbus_method_call(interface->path,
+			SUPPLICANT_INTERFACE ".Interface.P2PDevice", "RejectPeer",
+			interface_p2p_reject_params, interface_p2p_reject_peer_result, data, NULL);
+
+	if (ret < 0) {
+		g_free(data->path);
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
 struct interface_p2p_sd_data {
 	GSupplicantInterface *interface;
 	GSupplicantInterfaceCallback callback;
@@ -8778,6 +8823,42 @@ static void interface_p2p_sd_cancel_request_params(DBusMessageIter *iter, void *
 		dbus_message_iter_append_basic(iter, DBUS_TYPE_UINT64, request_id);
 	}
 }
+
+int g_supplicant_interface_p2p_sd_cancel_request(GSupplicantInterface *interface,
+				dbus_uint64_t request_id,
+				GSupplicantInterfaceCallback callback,
+				void *user_data)
+{
+	struct interface_p2p_sd_data *data;
+	int ret;
+
+	if (interface == NULL)
+		return -EINVAL;
+
+	if (system_available == FALSE)
+		return -EFAULT;
+
+	data = dbus_malloc0(sizeof(*data));
+	if (data == NULL)
+		return -ENOMEM;
+
+	data->interface = interface;
+	data->callback = callback;
+	data->user_data = user_data;
+	data->p2p_sd_params = (void*)&request_id;
+
+	ret = supplicant_dbus_method_call(interface->path,
+									  SUPPLICANT_INTERFACE ".Interface.P2PDevice", "ServiceDiscoveryCancelRequest",
+									  interface_p2p_sd_cancel_request_params, interface_p2p_sd_cancel_request_result, data, NULL);
+
+	if (ret < 0) {
+		dbus_free(data);
+		return ret;
+	}
+
+	return -EINPROGRESS;
+}
+
 struct p2p_service_data {
 	bool registration;
 	GSupplicantInterface *interface;
@@ -9945,6 +10026,12 @@ int g_supplicant_register(const GSupplicantCallbacks *callbacks)
 								NULL, NULL);
 	config_file_table = g_hash_table_new_full(g_str_hash, g_str_equal,
 								g_free, g_free);
+	intf_addr_mapping = g_hash_table_new_full(g_str_hash, g_str_equal,
+								g_free, NULL);
+	dev_addr_mapping = g_hash_table_new_full(g_str_hash, g_str_equal,
+								g_free, g_free);
+	p2p_peer_table = g_hash_table_new_full(g_str_hash, g_str_equal,
+								g_free, NULL);
 
 	supplicant_dbus_setup(connection);
 
@@ -10048,6 +10135,15 @@ void g_supplicant_unregister(const GSupplicantCallbacks *callbacks)
 		connection = NULL;
 	}
 
+	if (intf_addr_mapping){
+		g_hash_table_destroy(intf_addr_mapping);
+		intf_addr_mapping = NULL;
+	}
+	if (p2p_peer_table != NULL){
+		g_hash_table_destroy(p2p_peer_table);
+		p2p_peer_table = NULL;
+	}
+
 	callbacks_pointer = NULL;
 	eap_methods = 0;
 }
diff --git a/plugins/wifi.c b/plugins/wifi.c
index bc390870..80bdb60d 100644
--- a/plugins/wifi.c
+++ b/plugins/wifi.c
@@ -51,7 +51,7 @@
 #include <connman/service.h>
 #include <connman/peer.h>
 #include <connman/log.h>
-#include <include/option.h>
+#include <connman/option.h>
 #include <connman/storage.h>
 #include <include/setting.h>
 #include <connman/provision.h>
@@ -78,9 +78,9 @@
 #define P2P_PERSISTENT_INFO		"P2PPersistentInfo"
 
 #define P2P_FIND_TIMEOUT 30
-#define P2P_CONNECTION_TIMEOUT 100
-#define P2P_LISTEN_PERIOD 500
-#define P2P_LISTEN_INTERVAL 2000
+#define P2P_CONNECTION_TIMEOUT 60
+#define P2P_LISTEN_PERIOD 450
+#define P2P_LISTEN_INTERVAL 500
 #define P2P_PERSISTENT_MAX_COUNT 20
 
 #define ASSOC_STATUS_AUTH_TIMEOUT 16
@@ -1316,8 +1316,8 @@ static int peer_reject(struct connman_peer *peer)
 
 	peer_params.path = g_strdup(g_supplicant_peer_get_path(gs_peer));
 
-	ret = g_supplicant_interface_p2p_disconnect(wifi->interface,
-							&peer_params);
+	ret = g_supplicant_interface_p2p_reject(wifi->interface,
+							&peer_params, reject_peer_callback, peer);
 	g_free(peer_params.path);
 
 	if (ret == -EINPROGRESS) {
@@ -2590,7 +2590,7 @@ static int wifi_enable(struct connman_device *device)
 	struct wifi_data *wifi = connman_device_get_data(device);
 	int index;
 	char *interface;
-	const char *driver = connman_setting_get_string("wifi");
+	const char *driver = connman_option_get_string("wifi");
 	int ret;
 
 	DBG("device %p %p", device, wifi);
@@ -3675,10 +3675,10 @@ static void disconnect_callback(int result, GSupplicantInterface *interface,
 		return;
 	}
 
-	if (g_slist_find(wifi->networks, network))
+	//if (g_slist_find(wifi->networks, network))
 		connman_network_set_connected(network, false);
 
-	wifi->disconnecting = false;
+	//wifi->disconnecting = false;
 
 	if (network != wifi->network) {
 		if (network == wifi->pending_network)
@@ -3697,7 +3697,7 @@ static void disconnect_callback(int result, GSupplicantInterface *interface,
 		start_autoscan(wifi->device);
 	}
 
-	start_autoscan(wifi->device);
+	//start_autoscan(wifi->device);
 }
 
 static int network_disconnect(struct connman_network *network)
@@ -4448,8 +4448,7 @@ static int add_persistent_group_info(struct wifi_data *wifi)
 }
 static void p2p_support(GSupplicantInterface *interface)
 {
-	char dev_type[17] = {};
-	const char *hostname;
+	struct wifi_data *wifi = NULL;
 
 	DBG("");
 
@@ -4459,18 +4458,23 @@ static void p2p_support(GSupplicantInterface *interface)
 	if (!g_supplicant_interface_has_p2p(interface))
 		return;
 
+	wifi = g_supplicant_interface_get_data(interface);
+
+	if (!wifi)
+		return;
+
 	if (connman_technology_driver_register(&p2p_tech_driver) < 0) {
 		DBG("Could not register P2P technology driver");
 		return;
 	}
 
-	hostname = connman_utsname_get_hostname();
+	/*hostname = connman_utsname_get_hostname();
 	if (!hostname)
 		hostname = "ConnMan";
 
 	set_device_type(connman_machine_get_type(), dev_type);
 	g_supplicant_interface_set_p2p_device_config(interface,
-							hostname, dev_type);
+							hostname, dev_type);*/
 	connman_peer_driver_register(&peer_driver);
 }
 
@@ -4651,13 +4655,13 @@ static void network_added(GSupplicantNetwork *supplicant_network)
 
 		wifi->networks = g_slist_prepend(wifi->networks, network);
 
-		network_data = g_new0(struct wifi_network, 1);
-		connman_network_set_data(network, network_data);
+		//network_data = g_new0(struct wifi_network, 1);
+		//connman_network_set_data(network, network_data);
 	}
 
-	network_data = connman_network_get_data(network);
-	network_data->keymgmt =
-		g_supplicant_network_get_keymgmt(supplicant_network);
+	//network_data = connman_network_get_data(network);
+	//network_data->keymgmt =
+	//	g_supplicant_network_get_keymgmt(supplicant_network);
 
 	if (name && name[0] != '\0')
 		connman_network_set_name(network, name);
@@ -5300,8 +5304,8 @@ static void peer_changed(GSupplicantPeer *peer, GSupplicantPeerState state)
 	case G_SUPPLICANT_PEER_GROUP_CHANGED:
 		if (!g_supplicant_peer_is_in_a_group(peer))
 			p_state = CONNMAN_PEER_STATE_IDLE;
-		else
-			p_state = CONNMAN_PEER_STATE_CONFIGURATION;
+		//else
+		//	p_state = CONNMAN_PEER_STATE_CONFIGURATION;
 		break;
 	case G_SUPPLICANT_PEER_GROUP_STARTED:
 		break;
@@ -5387,8 +5391,10 @@ static void peer_changed(GSupplicantPeer *peer, GSupplicantPeerState state)
 		if (wifi->p2p_connecting
 				&& connman_peer == wifi->pending_peer)
 			peer_cancel_timeout(wifi);
-		else
-			p_state = CONNMAN_PEER_STATE_UNKNOWN;
+/*		else {
+			if (!p2p_go_identifier)
+				p_state = CONNMAN_PEER_STATE_UNKNOWN;
+		}*/
 	}
 
 	if (p_state == CONNMAN_PEER_STATE_UNKNOWN)
@@ -6099,7 +6105,7 @@ static void sta_remove_callback(int result,
 					void *user_data)
 {
 	struct wifi_tethering_info *info = user_data;
-	const char *driver = connman_setting_get_string("wifi");
+	const char *driver = connman_option_get_string("wifi");
 
 	DBG("ifname %s result %d ", info->ifname, result);
 

From ddaf58852e2b0bc7176e3132940fcf3a1cf22687 Mon Sep 17 00:00:00 2001
From: "penikelapati.kumar" <penikelapati.kumar@lge.com>
Date: Wed, 27 Jan 2021 18:56:41 +0530
Subject: [PATCH] Add p2p changes

:Release Notes:
Add new dbus methods related to p2p

:Detailed Notes:
Added code changes realted p2p joined with ip and generic mac address
solution for p2p devices.

:Testing Performed:
Build successfully.
Ethrenet/wifi connection successfully.

:QA Notes:
N/A

:Issues Addressed:
[PLAT-131728] Integrating and verification p2p/getstate, p2p/setstate
              and p2p/setgointent Luna API

Upstream-Status: Inappropriate[webos specific]
---
 src/ap/drv_callbacks.c                      |  11 ++
 src/ap/hostapd.c                            |  23 ++++
 src/ap/hostapd.h                            |   8 +-
 src/ap/sta_info.c                           |  23 +++-
 src/ap/wpa_auth.c                           |   2 +
 src/common/ieee802_11_defs.h                |   1 +
 src/p2p/p2p.c                               |  57 +++++++--
 src/p2p/p2p.h                               |   5 +
 src/p2p/p2p_build.c                         |  15 ++-
 src/p2p/p2p_go_neg.c                        |  40 ++++---
 src/p2p/p2p_group.c                         |  14 +++
 src/p2p/p2p_invitation.c                    |  48 +++++++-
 src/p2p/p2p_pd.c                            |   7 ++
 src/wps/wps_attr_build.c                    | 116 ++++++++++++++++++
 src/wps/wps_defs.h                          |  10 +-
 src/wps/wps_i.h                             |   1 +
 wpa_supplicant/ap.c                         |   4 +-
 wpa_supplicant/dbus/dbus_new.c              | 123 +++++++++++++++++++-
 wpa_supplicant/dbus/dbus_new.h              |  20 ++--
 wpa_supplicant/dbus/dbus_new_handlers.c     |  56 +++++++++
 wpa_supplicant/dbus/dbus_new_handlers.h     |   1 +
 wpa_supplicant/dbus/dbus_new_handlers_p2p.c |  34 +++++-
 wpa_supplicant/dbus/dbus_new_handlers_p2p.h |   2 +
 wpa_supplicant/notify.c                     |  34 ++++--
 wpa_supplicant/notify.h                     |   6 +-
 wpa_supplicant/p2p_supplicant.c             |  47 +++++++-
 wpa_supplicant/p2p_supplicant.h             |   1 +
 wpa_supplicant/wpa_supplicant.c             |  17 ++-
 28 files changed, 655 insertions(+), 71 deletions(-)

diff --git a/src/ap/drv_callbacks.c b/src/ap/drv_callbacks.c
index a50e6f2af..13737dcd8 100644
--- a/src/ap/drv_callbacks.c
+++ b/src/ap/drv_callbacks.c
@@ -202,6 +202,17 @@ int hostapd_notif_assoc(struct hostapd_data *hapd, const u8 *addr,
 			   "STA did not include WPS/RSN/WPA IE in (Re)AssocReq");
 	}
 
+#ifdef CONFIG_P2P
+	if (hapd->rejected_peer && os_memcmp(hapd->rejected_peer, addr, ETH_ALEN) == 0) {
+		hostapd_drv_sta_disassoc(hapd, addr,
+					WLAN_STATUS_UNACCEPTABLE_LIFETIME);
+		eloop_cancel_timeout(clear_rejected_peer_timeout, hapd, NULL);
+		eloop_register_timeout(5, 0,
+					clear_rejected_peer_timeout, hapd, NULL);
+		return -1;
+	}
+#endif /* CONFIG_P2P */
+
 	sta = ap_get_sta(hapd, addr);
 	if (sta) {
 		ap_sta_no_session_timeout(hapd, sta);
diff --git a/src/ap/hostapd.c b/src/ap/hostapd.c
index 4b88641a2..b537fe9e7 100644
--- a/src/ap/hostapd.c
+++ b/src/ap/hostapd.c
@@ -366,6 +366,12 @@ void hostapd_free_hapd_data(struct hostapd_data *hapd)
 	hapd->p2p_beacon_ie = NULL;
 	wpabuf_free(hapd->p2p_probe_resp_ie);
 	hapd->p2p_probe_resp_ie = NULL;
+
+	eloop_cancel_timeout(clear_rejected_peer_timeout, hapd, NULL);
+	if (hapd->rejected_peer) {
+		os_free(hapd->rejected_peer);
+		hapd->rejected_peer = NULL;
+	}
 #endif /* CONFIG_P2P */
 
 	if (!hapd->started) {
@@ -2376,6 +2382,11 @@ hostapd_alloc_bss_data(struct hostapd_iface *hapd_iface,
 	if (conf)
 		hapd->driver = conf->driver;
 	hapd->ctrl_sock = -1;
+
+#ifdef CONFIG_P2P
+	hapd->rejected_peer = NULL;
+#endif /* CONFIG_P2P */
+
 	dl_list_init(&hapd->ctrl_dst);
 	dl_list_init(&hapd->nr_db);
 	hapd->dhcp_sock = -1;
@@ -3768,3 +3779,15 @@ void hostapd_ocv_check_csa_sa_query(void *eloop_ctx, void *timeout_ctx)
 	}
 }
 #endif /* CONFIG_OCV */
+
+#ifdef CONFIG_P2P
+void clear_rejected_peer_timeout(void *eloop_ctx, void *timeout_ctx)
+{
+	struct hostapd_data *hapd = eloop_ctx;
+
+	if (hapd && hapd->rejected_peer) {
+		os_free(hapd->rejected_peer);
+		hapd->rejected_peer = NULL;
+	}
+}
+#endif /* CONFIG_P2P */
diff --git a/src/ap/hostapd.h b/src/ap/hostapd.h
index f3ca7529a..dc40c6a88 100644
--- a/src/ap/hostapd.h
+++ b/src/ap/hostapd.h
@@ -273,7 +273,7 @@ struct hostapd_data {
 	void *wps_event_cb_ctx;
 
 	void (*sta_authorized_cb)(void *ctx, const u8 *mac_addr,
-				  int authorized, const u8 *p2p_dev_addr);
+				  int authorized, const u8 *p2p_dev_addr, const char *ip_addr);
 	void *sta_authorized_cb_ctx;
 
 	void (*setup_complete_cb)(void *ctx);
@@ -300,6 +300,8 @@ struct hostapd_data {
 	struct wpabuf *p2p_beacon_ie;
 	struct wpabuf *p2p_probe_resp_ie;
 
+	u8* rejected_peer;
+
 	/* Number of non-P2P association stations */
 	int num_sta_no_p2p;
 
@@ -692,4 +694,8 @@ void fst_hostapd_fill_iface_obj(struct hostapd_data *hapd,
 				struct fst_wpa_obj *iface_obj);
 #endif /* CONFIG_FST */
 
+#ifdef CONFIG_P2P
+void clear_rejected_peer_timeout(void *eloop_ctx, void *timeout_ctx);
+#endif /* CONFIG_P2P */
+
 #endif /* HOSTAPD_H */
diff --git a/src/ap/sta_info.c b/src/ap/sta_info.c
index ccd1ed931..7402731a3 100644
--- a/src/ap/sta_info.c
+++ b/src/ap/sta_info.c
@@ -1268,6 +1268,8 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 #ifdef CONFIG_P2P
 	u8 addr[ETH_ALEN];
 	u8 ip_addr_buf[4];
+	char ip_info[100];
+	int is_ip_addr = -1;
 #endif /* CONFIG_P2P */
 
 	if (!!authorized == !!(sta->flags & WLAN_STA_AUTHORIZED))
@@ -1293,23 +1295,27 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 #endif /* CONFIG_P2P */
 		os_snprintf(buf, sizeof(buf), MACSTR, MAC2STR(sta->addr));
 
-	if (hapd->sta_authorized_cb)
-		hapd->sta_authorized_cb(hapd->sta_authorized_cb_ctx,
-					sta->addr, authorized, dev_addr);
-
 	if (authorized) {
 		const char *keyid;
 		char keyid_buf[100];
 		char ip_addr[100];
 
 		keyid_buf[0] = '\0';
+		ip_info[0] = '\0';
 		ip_addr[0] = '\0';
 #ifdef CONFIG_P2P
 		if (wpa_auth_get_ip_addr(sta->wpa_sm, ip_addr_buf) == 0) {
+			is_ip_addr = 1;
+
 			os_snprintf(ip_addr, sizeof(ip_addr),
 				    " ip_addr=%u.%u.%u.%u",
 				    ip_addr_buf[0], ip_addr_buf[1],
 				    ip_addr_buf[2], ip_addr_buf[3]);
+
+			os_snprintf(ip_info, sizeof(ip_info),
+								"%u.%u.%u.%u",
+								ip_addr_buf[0], ip_addr_buf[1],
+								ip_addr_buf[2], ip_addr_buf[3]);
 		}
 #endif /* CONFIG_P2P */
 
@@ -1336,6 +1342,15 @@ void ap_sta_set_authorized(struct hostapd_data *hapd, struct sta_info *sta,
 					  AP_STA_DISCONNECTED "%s", buf);
 	}
 
+	if (hapd->sta_authorized_cb) {
+		if (is_ip_addr < 0)
+			hapd->sta_authorized_cb(hapd->sta_authorized_cb_ctx,
+								sta->addr, authorized, dev_addr, NULL);
+		else
+			hapd->sta_authorized_cb(hapd->sta_authorized_cb_ctx,
+								sta->addr, authorized, dev_addr, ip_info);
+	}
+
 #ifdef CONFIG_FST
 	if (hapd->iface->fst) {
 		if (authorized)
diff --git a/src/ap/wpa_auth.c b/src/ap/wpa_auth.c
index 6d60f2629..824c3b195 100644
--- a/src/ap/wpa_auth.c
+++ b/src/ap/wpa_auth.c
@@ -729,6 +729,7 @@ void wpa_auth_sta_no_wpa(struct wpa_state_machine *sm)
 
 static void wpa_free_sta_sm(struct wpa_state_machine *sm)
 {
+#if 0
 #ifdef CONFIG_P2P
 	if (WPA_GET_BE32(sm->ip_addr)) {
 		u32 start;
@@ -743,6 +744,7 @@ static void wpa_free_sta_sm(struct wpa_state_machine *sm)
 			       WPA_GET_BE32(sm->ip_addr) - start);
 	}
 #endif /* CONFIG_P2P */
+#endif
 	if (sm->GUpdateStationKeys) {
 		sm->group->GKeyDoneStations--;
 		sm->GUpdateStationKeys = false;
diff --git a/src/common/ieee802_11_defs.h b/src/common/ieee802_11_defs.h
index 928b53500..6f1e824bc 100644
--- a/src/common/ieee802_11_defs.h
+++ b/src/common/ieee802_11_defs.h
@@ -1715,6 +1715,7 @@ enum p2p_role_indication {
 
 #define P2P_WILDCARD_SSID "DIRECT-"
 #define P2P_WILDCARD_SSID_LEN 7
+#define MAX_P2P_SSID_LEN 32
 
 /* P2P action frames */
 enum p2p_act_frame_type {
diff --git a/src/p2p/p2p.c b/src/p2p/p2p.c
index 598a449c1..a045f4aa7 100644
--- a/src/p2p/p2p.c
+++ b/src/p2p/p2p.c
@@ -1319,6 +1319,7 @@ void p2p_stop_find_for_freq(struct p2p_data *p2p, int freq)
 	p2p->go_neg_peer = NULL;
 	p2p->sd_peer = NULL;
 	p2p->invite_peer = NULL;
+	p2p->p2p_scan_running = 0;
 	p2p_stop_listen_for_freq(p2p, freq);
 	p2p->send_action_in_progress = 0;
 }
@@ -1326,6 +1327,10 @@ void p2p_stop_find_for_freq(struct p2p_data *p2p, int freq)
 
 void p2p_stop_listen_for_freq(struct p2p_data *p2p, int freq)
 {
+	if(!p2p) {
+		p2p_dbg(p2p, "p2p data is null");
+		return;
+	}
 	if (freq > 0 &&
 	    ((p2p->drv_in_listen == freq && p2p->in_listen) ||
 	     p2p->pending_listen_freq == (unsigned int) freq)) {
@@ -1646,15 +1651,26 @@ int p2p_connect(struct p2p_data *p2p, const u8 *peer_addr,
 	dev->go_neg_req_sent = 0;
 	dev->go_state = UNKNOWN_GO;
 	p2p_set_dev_persistent(dev, persistent_group);
-	p2p->go_intent = go_intent;
 	os_memcpy(p2p->intended_addr, own_interface_addr, ETH_ALEN);
 
+	p2p_dbg(p2p, "Peer's go intent %d ", dev->info.go_intent);
+
+	/*If Peer's go intent value is 15, set p2p go intent to 1 for compatibility */
+	if (dev->info.go_intent == P2P_MAX_GO_INTENT) {
+		p2p->go_intent = 1;
+		p2p_dbg(p2p, "Peer's go intent value is 15, set to go intent %d", p2p->go_intent);
+	} else {
+		p2p->go_intent = go_intent;
+		p2p_dbg(p2p, "Set p2p go intent to %d", p2p->go_intent);
+	}
+
 	if (p2p->state != P2P_IDLE)
 		p2p_stop_find(p2p);
 
 	dev->wps_method = wps_method;
 	dev->oob_pw_id = oob_pw_id;
-	dev->status = P2P_SC_SUCCESS;
+	if (dev->status != P2P_SC_FAIL_REJECTED_BY_USER)
+		dev->status = P2P_SC_SUCCESS;
 
 	if (p2p->p2p_scan_running) {
 		p2p_dbg(p2p, "p2p_scan running - delay connect send");
@@ -1746,6 +1762,11 @@ void p2p_add_dev_info(struct p2p_data *p2p, const u8 *addr,
 		}
 	}
 
+	if(msg->go_intent) {
+		dev->info.go_intent = (*msg->go_intent >> 1);
+		p2p_dbg(p2p, "P2P: Peer's p2p go intent value is %d", dev->info.go_intent);
+	}
+
 	if (msg->wfd_subelems) {
 		wpabuf_free(dev->info.wfd_subelems);
 		dev->info.wfd_subelems = wpabuf_dup(msg->wfd_subelems);
@@ -1780,9 +1801,12 @@ void p2p_build_ssid(struct p2p_data *p2p, u8 *ssid, size_t *ssid_len)
 {
 	os_memcpy(ssid, P2P_WILDCARD_SSID, P2P_WILDCARD_SSID_LEN);
 	p2p_random((char *) &ssid[P2P_WILDCARD_SSID_LEN], 2);
-	os_memcpy(&ssid[P2P_WILDCARD_SSID_LEN + 2],
-		  p2p->cfg->ssid_postfix, p2p->cfg->ssid_postfix_len);
 	*ssid_len = P2P_WILDCARD_SSID_LEN + 2 + p2p->cfg->ssid_postfix_len;
+
+	if (*ssid_len < MAX_P2P_SSID_LEN)
+		os_memcpy(&ssid[P2P_WILDCARD_SSID_LEN + 2], p2p->cfg->ssid_postfix, p2p->cfg->ssid_postfix_len);
+	else if (*ssid_len == MAX_P2P_SSID_LEN)
+		*ssid_len = P2P_WILDCARD_SSID_LEN + 2;
 }
 
 
@@ -2985,7 +3009,8 @@ struct p2p_data * p2p_init(const struct p2p_config *cfg)
 	p2p->dev_capab |= P2P_DEV_CAPAB_INVITATION_PROCEDURE;
 	if (cfg->concurrent_operations)
 		p2p->dev_capab |= P2P_DEV_CAPAB_CONCURRENT_OPER;
-	p2p->dev_capab |= P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY;
+	/* Client discoverability disabled */
+	p2p->dev_capab &= ~P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY;
 
 	dl_list_init(&p2p->devices);
 
@@ -3259,6 +3284,9 @@ void p2p_continue_find(struct p2p_data *p2p)
 	struct p2p_device *dev;
 	int found, res;
 
+	if (p2p == NULL)
+		return;
+
 	p2p_set_state(p2p, P2P_SEARCH);
 
 	/* Continue from the device following the last iteration */
@@ -4622,10 +4650,8 @@ static void p2p_ext_listen_timeout(void *eloop_ctx, void *timeout_ctx)
 				       p2p_ext_listen_timeout, p2p, NULL);
 	}
 
-	if ((p2p->cfg->is_p2p_in_progress &&
-	     p2p->cfg->is_p2p_in_progress(p2p->cfg->cb_ctx)) ||
-	    (p2p->pending_action_state == P2P_PENDING_PD &&
-	     p2p->pd_retries > 0)) {
+	if (p2p->pending_action_state == P2P_PENDING_PD &&
+	     p2p->pd_retries > 0) {
 		p2p_dbg(p2p, "Operation in progress - skip Extended Listen timeout (%s)",
 			p2p_state_txt(p2p->state));
 		return;
@@ -4643,6 +4669,14 @@ static void p2p_ext_listen_timeout(void *eloop_ctx, void *timeout_ctx)
 		p2p_set_state(p2p, P2P_IDLE);
 	}
 
+	if (p2p->cfg->is_p2p_in_progress &&
+	     p2p->cfg->is_p2p_in_progress(p2p->cfg->cb_ctx)) {
+		p2p_dbg(p2p, "Connection in progress - skip Extended Listen timeout (%s)",
+			p2p_state_txt(p2p->state));
+		return;
+	}
+
+
 	if (p2p->state != P2P_IDLE) {
 		p2p_dbg(p2p, "Skip Extended Listen timeout in active state (%s)", p2p_state_txt(p2p->state));
 		return;
@@ -4670,13 +4704,13 @@ int p2p_ext_listen(struct p2p_data *p2p, unsigned int period,
 	eloop_cancel_timeout(p2p_ext_listen_timeout, p2p, NULL);
 
 	if (interval == 0) {
-		p2p_dbg(p2p, "Disabling Extended Listen Timing");
+		p2p_info(p2p, "Disabling Extended Listen Timing");
 		p2p->ext_listen_period = 0;
 		p2p->ext_listen_interval = 0;
 		return 0;
 	}
 
-	p2p_dbg(p2p, "Enabling Extended Listen Timing: period %u msec, interval %u msec",
+	p2p_info(p2p, "Enabling Extended Listen Timing: period %u msec, interval %u msec",
 		period, interval);
 	p2p->ext_listen_period = period;
 	p2p->ext_listen_interval = interval;
@@ -4781,6 +4815,7 @@ int p2p_set_listen_channel(struct p2p_data *p2p, u8 reg_class, u8 channel,
 		reg_class, channel);
 
 	if (p2p->state == P2P_IDLE) {
+		p2p->pending_listen_freq = 0;
 		p2p->cfg->reg_class = reg_class;
 		p2p->cfg->channel = channel;
 		p2p->cfg->channel_forced = forced;
diff --git a/src/p2p/p2p.h b/src/p2p/p2p.h
index f606fbb14..6b934bfd9 100644
--- a/src/p2p/p2p.h
+++ b/src/p2p/p2p.h
@@ -377,6 +377,11 @@ struct p2p_peer_info {
 	 */
 	u8 group_capab;
 
+	/**
+	 * go_intent - p2p go intent value
+	 */
+	u8 go_intent;
+
 	/**
 	 * wps_sec_dev_type_list - WPS secondary device type list
 	 *
diff --git a/src/p2p/p2p_build.c b/src/p2p/p2p_build.c
index 4229d9b34..5f23caa2b 100644
--- a/src/p2p/p2p_build.c
+++ b/src/p2p/p2p_build.c
@@ -223,10 +223,14 @@ void p2p_buf_add_device_info(struct wpabuf *buf, struct p2p_data *p2p,
 			sizeof(p2p->cfg->pri_dev_type));
 
 	/* Number of Secondary Device Types */
-	wpabuf_put_u8(buf, p2p->cfg->num_sec_dev_types);
+	wpabuf_put_u8(buf, p2p->cfg->num_sec_dev_types + 1);
+
+	/* Prepend Intel OUI (see Gen4 WiDi Sink Technical Specification, chapter 3.2) */
+	u8 intel_oui[8] = { 00, 07, 00, 23, 53, 32, 00, 02 };
+	wpabuf_put_data(buf, intel_oui, WPS_DEV_TYPE_LEN);
 
 	/* Secondary Device Type List */
-	for (i = 0; i < p2p->cfg->num_sec_dev_types; i++)
+	for (i = 1; i < p2p->cfg->num_sec_dev_types; i++)
 		wpabuf_put_data(buf, p2p->cfg->sec_dev_type[i],
 				WPS_DEV_TYPE_LEN);
 
@@ -805,13 +809,20 @@ int p2p_build_wps_ie(struct p2p_data *p2p, struct wpabuf *buf, int pw_id,
 	if (wps_build_wfa_ext(buf, 0, NULL, 0, 0) < 0)
 		return -1;
 
+	if (wps_build_wfa_ext_ms(buf, p2p->cfg->dev_name, p2p->cfg->dev_addr) < 0)
+		wpa_printf(MSG_DEBUG, "WPS: *MS failed to build wps_build_wfa_ext_ms");
+
 	if (all_attr && p2p->cfg->num_sec_dev_types) {
 		if (wpabuf_tailroom(buf) <
 		    4 + WPS_DEV_TYPE_LEN * p2p->cfg->num_sec_dev_types)
 			return -1;
+		/* Prepend Intel OUI (see Gen4 WiDi Sink Technical Specification, chapter 3.2) */
+		u8 intel_oui[8] = { 00, 07, 00, 23, 53, 32, 00, 02 };
 		wpabuf_put_be16(buf, ATTR_SECONDARY_DEV_TYPE_LIST);
+		wpabuf_put_be16(buf, WPS_DEV_TYPE_LEN);
 		wpabuf_put_be16(buf, WPS_DEV_TYPE_LEN *
 				p2p->cfg->num_sec_dev_types);
+		wpabuf_put_data(buf, intel_oui, WPS_DEV_TYPE_LEN);
 		wpabuf_put_data(buf, p2p->cfg->sec_dev_type,
 				WPS_DEV_TYPE_LEN *
 				p2p->cfg->num_sec_dev_types);
diff --git a/src/p2p/p2p_go_neg.c b/src/p2p/p2p_go_neg.c
index 1d53d52f1..a69b4f5e9 100644
--- a/src/p2p/p2p_go_neg.c
+++ b/src/p2p/p2p_go_neg.c
@@ -171,6 +171,18 @@ static struct wpabuf * p2p_build_go_neg_req(struct p2p_data *p2p,
 	p2p_buf_add_capability(buf, p2p->dev_capab &
 			       ~P2P_DEV_CAPAB_CLIENT_DISCOVERABILITY,
 			       group_capab);
+	/*
+	 * This statement provided MC should be added to indicate the
+	 * rejection of GO Negotiation to remote device when we combinate the
+	 * rejectPeer() and connect() APIs.
+	 *
+	 * FIXME: The setting of P2P_SC_FAIL_REJECTED_BY_USER is against the spec.
+	 * But apparently still being used in practice. We need to find a better
+	 * solution for this issue.
+	 */
+	if (peer->status == P2P_SC_FAIL_REJECTED_BY_USER)
+		p2p_buf_add_status(buf, P2P_SC_FAIL_INVALID_PARAMS);
+
 	p2p_buf_add_go_intent(buf, (p2p->go_intent << 1) | peer->tie_breaker);
 	p2p_buf_add_config_timeout(buf, p2p->go_timeout, p2p->client_timeout);
 	p2p_buf_add_listen_channel(buf, p2p->cfg->country, p2p->cfg->reg_class,
@@ -463,6 +475,18 @@ void p2p_reselect_channel(struct p2p_data *p2p,
 		return;
 	}
 
+	/*
+         * Try to see if the original channel is in the intersection. If
+         * so, no need to change anything, as it already contains some
+         * randomness.
+         */
+	if (p2p_channels_includes(intersection, p2p->op_reg_class,
+				  p2p->op_channel)) {
+		p2p_dbg(p2p, "Using original operating class and channel (op_class %u channel %u) from intersection",
+			p2p->op_reg_class, p2p->op_channel);
+		return;
+	}
+
 	/* Try a channel where we might be able to use VHT */
 	if (p2p_channel_select(intersection, op_classes_vht,
 			       &p2p->op_reg_class, &p2p->op_channel) == 0) {
@@ -487,18 +511,6 @@ void p2p_reselect_channel(struct p2p_data *p2p,
 		return;
 	}
 
-	/*
-	 * Try to see if the original channel is in the intersection. If
-	 * so, no need to change anything, as it already contains some
-	 * randomness.
-	 */
-	if (p2p_channels_includes(intersection, p2p->op_reg_class,
-				  p2p->op_channel)) {
-		p2p_dbg(p2p, "Using original operating class and channel (op_class %u channel %u) from intersection",
-			p2p->op_reg_class, p2p->op_channel);
-		return;
-	}
-
 	/*
 	 * Fall back to whatever is included in the channel intersection since
 	 * no better options seems to be available.
@@ -840,14 +852,14 @@ void p2p_process_go_neg_req(struct p2p_data *p2p, const u8 *sa,
 	else if ((dev->flags & P2P_DEV_PROBE_REQ_ONLY) ||
 		  !(dev->flags & P2P_DEV_REPORTED))
 		p2p_add_dev_info(p2p, sa, dev, &msg);
-	else if (!dev->listen_freq && !dev->oper_freq) {
+	else if ((!dev->listen_freq && !dev->oper_freq) || dev->info.go_intent == 0) {
 		/*
 		 * This may happen if the peer entry was added based on PD
 		 * Request and no Probe Request/Response frame has been received
 		 * from this peer (or that information has timed out).
 		 */
 		p2p_dbg(p2p, "Update peer " MACSTR
-			" based on GO Neg Req since listen/oper freq not known",
+			" based on GO Neg Req since listen/oper freq or go intent not known",
 			MAC2STR(dev->info.p2p_device_addr));
 		p2p_add_dev_info(p2p, sa, dev, &msg);
 	}
diff --git a/src/p2p/p2p_group.c b/src/p2p/p2p_group.c
index aa18af6c1..4e4260125 100644
--- a/src/p2p/p2p_group.c
+++ b/src/p2p/p2p_group.c
@@ -349,6 +349,13 @@ static int wifi_display_add_dev_info_descr(struct wpabuf *buf,
 	return 1;
 }
 
+static void wifi_display_set_alternative_mac(struct wpabuf *e, const u8 *addr)
+{
+	wpabuf_put_u8(e, WFD_SUBELEM_MAC_INFO);
+	wpabuf_put_be16(e, ETH_ALEN);
+	wpabuf_put_data(e, addr, ETH_ALEN);
+}
+
 
 static struct wpabuf *
 wifi_display_build_go_ie(struct p2p_group *group)
@@ -396,6 +403,10 @@ wifi_display_build_go_ie(struct p2p_group *group)
 			count);
 	}
 
+	/* Build alternative MAC address*/
+	if (os_memcmp(group->p2p->cfg->dev_addr, group->p2p->intended_addr, ETH_ALEN) !=0)
+		wifi_display_set_alternative_mac(wfd_subelems, group->p2p->intended_addr);
+
 	wfd_ie = wifi_display_encaps(wfd_subelems);
 	wpabuf_free(wfd_subelems);
 
@@ -760,6 +771,9 @@ int p2p_group_match_dev_type(struct p2p_group *group, struct wpabuf *wps)
 {
 	struct p2p_group_member *m;
 
+	if (group == NULL)
+		return 0;
+
 	if (p2p_match_dev_type(group->p2p, wps))
 		return 1; /* Match with own device type */
 
diff --git a/src/p2p/p2p_invitation.c b/src/p2p/p2p_invitation.c
index ab0072219..8ac71026f 100644
--- a/src/p2p/p2p_invitation.c
+++ b/src/p2p/p2p_invitation.c
@@ -170,6 +170,43 @@ static struct wpabuf * p2p_build_invitation_resp(struct p2p_data *p2p,
 	return buf;
 }
 
+static void p2p_select_default_channel(struct p2p_data *p2p,
+			  struct p2p_channels *intersection)
+{
+	const int op_classes_5ghz[] = { 124, 125, 115, 0 };
+	const int op_classes_ht40[] = { 126, 127, 116, 117, 0 };
+	const int op_classes_vht[] = { 128, 129, 130, 0 };
+
+	/* Try a channel where we might be able to use VHT */
+	if (p2p_channel_select(intersection, op_classes_vht,
+			       &p2p->op_reg_class, &p2p->op_channel) == 0) {
+		p2p_dbg(p2p, "Pick possible VHT channel (op_class %u channel %u) from intersection",
+			p2p->op_reg_class, p2p->op_channel);
+		return;
+	}
+
+	/* Try a channel where we might be able to use HT40 */
+	if (p2p_channel_select(intersection, op_classes_ht40,
+			       &p2p->op_reg_class, &p2p->op_channel) == 0) {
+		p2p_dbg(p2p, "Pick possible HT40 channel (op_class %u channel %u) from intersection",
+			p2p->op_reg_class, p2p->op_channel);
+		return;
+	}
+
+	/* Prefer a 5 GHz channel */
+	if (p2p_channel_select(intersection, op_classes_5ghz,
+			       &p2p->op_reg_class, &p2p->op_channel) == 0) {
+		p2p_dbg(p2p, "Pick possible 5 GHz channel (op_class %u channel %u) from intersection",
+			p2p->op_reg_class, p2p->op_channel);
+		return;
+	}
+
+	/* Default to own configuration as a starting point */
+	p2p->op_reg_class = p2p->cfg->op_reg_class;
+	p2p->op_channel = p2p->cfg->op_channel;
+	p2p_dbg(p2p, "Pick operating class and channel (op_class %u channel %u) from configuration",
+			p2p->op_reg_class, p2p->op_channel);
+}
 
 void p2p_process_invitation_req(struct p2p_data *p2p, const u8 *sa,
 				const u8 *data, size_t len, int rx_freq)
@@ -213,7 +250,15 @@ void p2p_process_invitation_req(struct p2p_data *p2p, const u8 *sa,
 				MACSTR, MAC2STR(sa));
 			status = P2P_SC_FAIL_INFO_CURRENTLY_UNAVAILABLE;
 			goto fail;
+		} else {
+			p2p_add_dev_info(p2p, sa, dev, &msg);
+			p2p_dbg(p2p, "Update peer info from Invitation Request "
+				"peer " MACSTR, MAC2STR(sa));
 		}
+	} else {
+		p2p_add_dev_info(p2p, sa, dev, &msg);
+		p2p_dbg(p2p, "Update peer info from Invitation Request "
+			"peer " MACSTR, MAC2STR(sa));
 	}
 
 	if (!msg.group_id || !msg.channel_list) {
@@ -296,8 +341,7 @@ void p2p_process_invitation_req(struct p2p_data *p2p, const u8 *sa,
 		p2p_dbg(p2p, "No forced channel from invitation processing - figure out best one to use");
 
 		/* Default to own configuration as a starting point */
-		p2p->op_reg_class = p2p->cfg->op_reg_class;
-		p2p->op_channel = p2p->cfg->op_channel;
+		p2p_select_default_channel(p2p, &intersection);
 		p2p_dbg(p2p, "Own default op_class %d channel %d",
 			p2p->op_reg_class, p2p->op_channel);
 
diff --git a/src/p2p/p2p_pd.c b/src/p2p/p2p_pd.c
index 338b47e4e..f7a84f344 100644
--- a/src/p2p/p2p_pd.c
+++ b/src/p2p/p2p_pd.c
@@ -602,6 +602,13 @@ void p2p_process_prov_disc_req(struct p2p_data *p2p, const u8 *sa,
 				MACSTR, MAC2STR(sa));
 			goto out;
 		}
+
+		dev = p2p_get_device(p2p, sa);
+		if (dev != NULL) {
+			p2p_add_dev_info(p2p, sa, dev, &msg);
+			p2p_dbg(p2p, "Update peer info from Provision Discovery Request "
+				"peer " MACSTR, MAC2STR(sa));
+		}
 	} else if (msg.wfd_subelems) {
 		wpabuf_free(dev->info.wfd_subelems);
 		dev->info.wfd_subelems = wpabuf_dup(msg.wfd_subelems);
diff --git a/src/wps/wps_attr_build.c b/src/wps/wps_attr_build.c
index f37225676..6459f20fc 100644
--- a/src/wps/wps_attr_build.c
+++ b/src/wps/wps_attr_build.c
@@ -9,6 +9,11 @@
 #include "includes.h"
 
 #include "common.h"
+#include <net/if.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <linux/wireless.h>
 #include "crypto/aes_wrap.h"
 #include "crypto/crypto.h"
 #include "crypto/dh_group5.h"
@@ -204,6 +209,117 @@ int wps_build_version(struct wpabuf *msg)
 	return 0;
 }
 
+int wps_build_wfa_ext_ms(struct wpabuf *msg, char *host_name, const u8 *mac)
+{
+	u8 *len;
+	char mdns_name[30] = "LGWEBOS";
+
+	int s, ret, freq = 0, wifi2_4 = 0, wifi5 = 0, eth = 0;
+	struct ifreq ifr;
+	struct iwreq wrq;
+	struct sockaddr_in *saddr;
+	char wlan0_address[16] = {0,};
+	char eth0_address[16] = {0,};
+	char mac_addr[13] = {0,};
+
+	// convert mac string "%02x%02x%02x%02x%02x%02x"
+	os_snprintf(mac_addr, sizeof(mac_addr), COMPACT_MACSTR, MAC2STR(mac));
+
+	if (os_strlen(mac_addr) < 12) {
+		return -1;
+	}
+
+	s = socket(PF_INET, SOCK_DGRAM | SOCK_CLOEXEC, 0);
+	if (s < 0) {
+		wpa_printf(MSG_ERROR, "%s: socket: %s",
+			   __func__, strerror(errno));
+		return -1;
+	} else {
+		for(int i = 0 ; i < 10 ; i++) {
+			os_memset(&ifr, 0, sizeof(struct ifreq));
+			os_memset(&wrq, 0, sizeof(struct iwreq));
+			ifr.ifr_ifindex = i;
+			ret = ioctl(s, SIOCGIFNAME, &ifr);
+			if(ret >= 0)
+			{
+				if (!os_memcmp(ifr.ifr_name, "eth0", 4)) {
+					if (ioctl(s, SIOCGIFADDR, &ifr) < 0) {
+						if (errno != EADDRNOTAVAIL)
+							wpa_printf(MSG_ERROR, "%s: ioctl[SIOCGIFADDR]: %s",
+									__func__, strerror(errno));
+					} else {
+						saddr = (struct sockaddr_in *)&ifr.ifr_addr;
+						inet_ntop(AF_INET, &saddr->sin_addr, eth0_address, sizeof(eth0_address));
+						eth = 1;
+					}
+				} else if (!os_memcmp(ifr.ifr_name, "wlan0", 5)) {
+					os_memcpy(wrq.ifr_name, ifr.ifr_name, sizeof(wrq.ifr_name));
+					if (ioctl(s, SIOCGIWFREQ, &wrq) >= 0) {
+						freq = wrq.u.freq.m / 1000;
+					}
+					if (freq > 2484) {
+						if (ioctl(s, SIOCGIFADDR, &ifr) < 0) {
+							if (errno != EADDRNOTAVAIL)
+								wpa_printf(MSG_ERROR, "%s: ioctl[SIOCGIFADDR]: %s",
+										__func__, strerror(errno));
+						} else {
+							saddr = (struct sockaddr_in *)&ifr.ifr_addr;
+							inet_ntop(AF_INET, &saddr->sin_addr, wlan0_address, sizeof(wlan0_address));
+							wifi5 = 1;
+						}
+					} else if (freq > 2411 && freq < 2485) {
+						wifi2_4 = 1;
+					}
+				}
+			}
+		}
+		close(s);
+	}
+
+	for(int i=3 ; i<6 ; i++) {
+		char temp[10];
+		os_snprintf(temp, sizeof(temp), "%02x",mac[i]);
+		strncat(mdns_name, temp, sizeof(temp));
+	}
+
+	if (wpabuf_tailroom(msg) < 7 + 5 + 36)
+		return -1;
+	wpabuf_put_be16(msg, ATTR_VENDOR_EXT);
+	len = wpabuf_put(msg, 2); /* to be filled */
+	wpabuf_put_be24(msg, WPS_VENDOR_ID_MS);
+
+	if (eth && (wifi2_4 || wifi5)) {
+		wpa_printf(MSG_DEBUG, "WPS:  * MS Infra eth wlan Dual Connection");
+	} else if (eth || wifi5) {
+		/* For MS Infrastructure Mode */
+		wpabuf_put_be16(msg, WFA_ELEM_MS_CAPABILITY);
+		wpabuf_put_be16(msg, 1);
+		wpabuf_put_u8(msg, 0x05);	//for support infrastructure
+
+		wpabuf_put_be16(msg, WFA_ELEM_MS_HOST_NAME);
+		wpabuf_put_be16(msg, os_strlen(mdns_name));
+		wpabuf_put_data(msg, mdns_name, os_strlen(mdns_name));
+
+		if (eth) {
+			wpa_printf(MSG_DEBUG, "WPS:  * MS Infra eth ip capa : %s, Host Name : %s",
+								eth0_address, mdns_name);
+			wpabuf_put_be16(msg, WFA_ELEM_MS_IP_ADDRESS);
+			wpabuf_put_be16(msg, os_strlen(eth0_address));
+			wpabuf_put_data(msg, eth0_address, os_strlen(eth0_address));
+		} else if (wifi5) {
+			wpa_printf(MSG_DEBUG, "WPS:  * MS Infra wlan ip capa : %s, freq : %d, Host Name : %s",
+								wlan0_address, freq, mdns_name);
+			wpabuf_put_be16(msg, WFA_ELEM_MS_IP_ADDRESS);
+			wpabuf_put_be16(msg, os_strlen(wlan0_address));
+			wpabuf_put_data(msg, wlan0_address, os_strlen(wlan0_address));
+		}
+	}
+
+	WPA_PUT_BE16(len, (u8 *) wpabuf_put(msg, 0) - len - 2);
+
+	return 0;
+}
+
 
 int wps_build_wfa_ext(struct wpabuf *msg, int req_to_enroll,
 		      const u8 *auth_macs, size_t auth_macs_count,
diff --git a/src/wps/wps_defs.h b/src/wps/wps_defs.h
index ddaeda56d..39f8f11a1 100644
--- a/src/wps/wps_defs.h
+++ b/src/wps/wps_defs.h
@@ -144,6 +144,7 @@ enum wps_attribute {
 };
 
 #define WPS_VENDOR_ID_WFA 14122
+#define WPS_VENDOR_ID_MS 311		//0x000137
 
 /* WFA Vendor Extension subelements */
 enum {
@@ -153,7 +154,14 @@ enum {
 	WFA_ELEM_REQUEST_TO_ENROLL = 0x03,
 	WFA_ELEM_SETTINGS_DELAY_TIME = 0x04,
 	WFA_ELEM_REGISTRAR_CONFIGURATION_METHODS = 0x05,
-	WFA_ELEM_MULTI_AP = 0x06
+	WFA_ELEM_MULTI_AP = 0x06,
+
+	/* For Microsoft Infrastructure mode */
+	WFA_ELEM_MS_CAPABILITY = 0x2001,
+	WFA_ELEM_MS_HOST_NAME = 0x2002,
+	WFA_ELEM_MS_BSSID = 0x2003,
+	WFA_ELEM_MS_CONNECTION_PREFERENCE = 0x2004,
+	WFA_ELEM_MS_IP_ADDRESS = 0x2005
 };
 
 /* Device Password ID */
diff --git a/src/wps/wps_i.h b/src/wps/wps_i.h
index 2cf22d4b7..423f5774e 100644
--- a/src/wps/wps_i.h
+++ b/src/wps/wps_i.h
@@ -167,6 +167,7 @@ int wps_build_version(struct wpabuf *msg);
 int wps_build_wfa_ext(struct wpabuf *msg, int req_to_enroll,
 		      const u8 *auth_macs, size_t auth_macs_count,
 		      u8 multi_ap_subelem);
+int wps_build_wfa_ext_ms(struct wpabuf *msg, char *host_name, const u8 *mac);
 int wps_build_msg_type(struct wpabuf *msg, enum wps_msg_type msg_type);
 int wps_build_enrollee_nonce(struct wps_data *wps, struct wpabuf *msg);
 int wps_build_registrar_nonce(struct wps_data *wps, struct wpabuf *msg);
diff --git a/wpa_supplicant/ap.c b/wpa_supplicant/ap.c
index 6a0a69e68..ba4983b55 100644
--- a/wpa_supplicant/ap.c
+++ b/wpa_supplicant/ap.c
@@ -832,9 +832,9 @@ static void ap_wps_event_cb(void *ctx, enum wps_event event,
 
 
 static void ap_sta_authorized_cb(void *ctx, const u8 *mac_addr,
-				 int authorized, const u8 *p2p_dev_addr)
+				 int authorized, const u8 *p2p_dev_addr, const char *ip_addr)
 {
-	wpas_notify_sta_authorized(ctx, mac_addr, authorized, p2p_dev_addr);
+	wpas_notify_sta_authorized(ctx, mac_addr, authorized, p2p_dev_addr, ip_addr);
 }
 
 
diff --git a/wpa_supplicant/dbus/dbus_new.c b/wpa_supplicant/dbus/dbus_new.c
index 9279ae4d5..c770128cd 100644
--- a/wpa_supplicant/dbus/dbus_new.c
+++ b/wpa_supplicant/dbus/dbus_new.c
@@ -27,6 +27,8 @@
 #include "p2p/p2p.h"
 #include "../p2p_supplicant.h"
 
+#define COMPACT_MACSTR_LEN	12
+
 #ifdef CONFIG_AP /* until needed by something else */
 
 /*
@@ -1564,10 +1566,12 @@ static void peer_groups_changed(struct wpa_supplicant *wpa_s)
  * @persistent: 0 - non persistent group, 1 - persistent group
  * @ip: When group role is client, it contains local IP address, netmask, and
  *	GO's IP address, if assigned; otherwise, NULL
+ * @go_dev_addr: GO 's device address'
+ * @freq: connected p2p channel
  */
 void wpas_dbus_signal_p2p_group_started(struct wpa_supplicant *wpa_s,
 					int client, int persistent,
-					const u8 *ip)
+					const u8 *ip, const u8 *go_dev_addr, int freq)
 {
 	DBusMessage *msg;
 	DBusMessageIter iter, dict_iter;
@@ -1607,6 +1611,10 @@ void wpas_dbus_signal_p2p_group_started(struct wpa_supplicant *wpa_s,
 	    !wpa_dbus_dict_append_string(&dict_iter, "role",
 					 client ? "client" : "GO") ||
 	    !wpa_dbus_dict_append_bool(&dict_iter, "persistent", persistent) ||
+	    (go_dev_addr &&
+	     !wpa_dbus_dict_append_byte_array(&dict_iter, "go_dev_addr",
+					      (const char *) go_dev_addr, ETH_ALEN)) ||
+		!wpa_dbus_dict_append_uint32(&dict_iter, "freq", freq) ||
 	    !wpa_dbus_dict_append_object_path(&dict_iter, "group_object",
 					      wpa_s->dbus_groupobj_path) ||
 	    (ip &&
@@ -1798,13 +1806,14 @@ void wpas_dbus_signal_p2p_invitation_result(struct wpa_supplicant *wpa_s,
  * @peer_addr: P2P Device Address of the peer joining the group
  */
 void wpas_dbus_signal_p2p_peer_joined(struct wpa_supplicant *wpa_s,
-				      const u8 *peer_addr)
+				      const u8 *peer_addr, const u8 *p2p_dev_addr)
 {
 	struct wpas_dbus_priv *iface;
 	DBusMessage *msg;
 	DBusMessageIter iter;
 	char peer_obj_path[WPAS_DBUS_OBJECT_PATH_MAX], *path;
 	struct wpa_supplicant *parent;
+	char dev_address[COMPACT_MACSTR_LEN + 1], *dev_addr;
 
 	iface = wpa_s->global->dbus;
 
@@ -1826,6 +1835,9 @@ void wpas_dbus_signal_p2p_peer_joined(struct wpa_supplicant *wpa_s,
 			COMPACT_MACSTR,
 			parent->dbus_new_path, MAC2STR(peer_addr));
 
+	os_memset(dev_address, 0, sizeof(dev_address));
+	os_snprintf(dev_address, sizeof(dev_address), COMPACT_MACSTR, MAC2STR(p2p_dev_addr));
+
 	msg = dbus_message_new_signal(wpa_s->dbus_groupobj_path,
 				      WPAS_DBUS_NEW_IFACE_P2P_GROUP,
 				      "PeerJoined");
@@ -1834,9 +1846,78 @@ void wpas_dbus_signal_p2p_peer_joined(struct wpa_supplicant *wpa_s,
 
 	dbus_message_iter_init_append(msg, &iter);
 	path = peer_obj_path;
+	dev_addr = dev_address;
 	if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_OBJECT_PATH,
 					    &path)) {
 		wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
+	} else if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &dev_addr)) {
+		wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
+	} else {
+		dbus_connection_send(iface->con, msg, NULL);
+		wpas_dbus_signal_peer_groups_changed(parent, peer_addr);
+	}
+	dbus_message_unref(msg);
+}
+
+
+/**
+ *
+ * Method to emit a signal for a peer joining the group.
+ * The signal will carry path to the group member object
+ * constructed using p2p i/f addr used for connecting.
+ *
+ * @wpa_s: %wpa_supplicant network interface data
+ * @peer_addr: P2P Device Address of the peer joining the group
+ */
+void wpas_dbus_signal_p2p_peer_joined_with_ip(struct wpa_supplicant *wpa_s,
+				      const u8 *peer_addr, const char *ip_addr, const u8 *p2p_dev_addr)
+{
+	struct wpas_dbus_priv *iface;
+	DBusMessage *msg;
+	DBusMessageIter iter;
+	char peer_obj_path[WPAS_DBUS_OBJECT_PATH_MAX], *path;
+	struct wpa_supplicant *parent;
+	char dev_address[COMPACT_MACSTR_LEN + 1], *dev_addr;
+
+	iface = wpa_s->global->dbus;
+
+	/* Do nothing if the control interface is not turned on */
+	if (iface == NULL)
+		return;
+
+	if (!wpa_s->dbus_groupobj_path)
+		return;
+
+	parent = wpa_s->parent;
+	if (parent->p2p_mgmt)
+		parent = parent->parent;
+	if (!parent->dbus_new_path)
+		return;
+
+	os_snprintf(peer_obj_path, WPAS_DBUS_OBJECT_PATH_MAX,
+			"%s/" WPAS_DBUS_NEW_P2P_PEERS_PART "/"
+			COMPACT_MACSTR,
+			parent->dbus_new_path, MAC2STR(peer_addr));
+
+	os_memset(dev_address, 0, sizeof(dev_address));
+	os_snprintf(dev_address, sizeof(dev_address), COMPACT_MACSTR, MAC2STR(p2p_dev_addr));
+
+	msg = dbus_message_new_signal(wpa_s->dbus_groupobj_path,
+				      WPAS_DBUS_NEW_IFACE_P2P_GROUP,
+				      "PeerJoinedWithIP");
+	if (msg == NULL)
+		return;
+
+	dbus_message_iter_init_append(msg, &iter);
+	path = peer_obj_path;
+	dev_addr = dev_address;
+	if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_OBJECT_PATH,
+					    &path)) {
+		wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
+	} else if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &ip_addr)) {
+		wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
+	} else if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &dev_addr)) {
+		wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
 	} else {
 		dbus_connection_send(iface->con, msg, NULL);
 		wpas_dbus_signal_peer_groups_changed(parent, peer_addr);
@@ -1855,13 +1936,14 @@ void wpas_dbus_signal_p2p_peer_joined(struct wpa_supplicant *wpa_s,
  * @peer_addr: P2P Device Address of the peer joining the group
  */
 void wpas_dbus_signal_p2p_peer_disconnected(struct wpa_supplicant *wpa_s,
-					    const u8 *peer_addr)
+					    const u8 *peer_addr, const u8 *p2p_dev_addr)
 {
 	struct wpas_dbus_priv *iface;
 	DBusMessage *msg;
 	DBusMessageIter iter;
 	char peer_obj_path[WPAS_DBUS_OBJECT_PATH_MAX], *path;
 	struct wpa_supplicant *parent;
+	char dev_address[COMPACT_MACSTR_LEN + 1], *dev_addr;
 
 	iface = wpa_s->global->dbus;
 
@@ -1883,6 +1965,9 @@ void wpas_dbus_signal_p2p_peer_disconnected(struct wpa_supplicant *wpa_s,
 			COMPACT_MACSTR,
 			parent->dbus_new_path, MAC2STR(peer_addr));
 
+	os_memset(dev_address, 0, sizeof(dev_address));
+	os_snprintf(dev_address, sizeof(dev_address), COMPACT_MACSTR, MAC2STR(p2p_dev_addr));
+
 	msg = dbus_message_new_signal(wpa_s->dbus_groupobj_path,
 				      WPAS_DBUS_NEW_IFACE_P2P_GROUP,
 				      "PeerDisconnected");
@@ -1891,10 +1976,13 @@ void wpas_dbus_signal_p2p_peer_disconnected(struct wpa_supplicant *wpa_s,
 
 	dbus_message_iter_init_append(msg, &iter);
 	path = peer_obj_path;
+	dev_addr = dev_address;
 	if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_OBJECT_PATH,
 					    &path)) {
 		wpa_printf(MSG_ERROR,
 			   "dbus: Failed to construct PeerDisconnected signal");
+	} else if (!dbus_message_iter_append_basic(&iter, DBUS_TYPE_STRING, &dev_addr)) {
+		wpa_printf(MSG_ERROR, "dbus: Failed to construct signal");
 	} else {
 		dbus_connection_send(iface->con, msg, NULL);
 		wpas_dbus_signal_peer_groups_changed(parent, peer_addr);
@@ -2198,6 +2286,9 @@ void wpas_dbus_signal_p2p_group_formation_failure(struct wpa_supplicant *wpa_s,
 	if (wpa_s->p2p_mgmt)
 		wpa_s = wpa_s->parent;
 
+	if (!wpa_s->dbus_new_path)
+		return;
+
 	msg = dbus_message_new_signal(wpa_s->dbus_new_path,
 				      WPAS_DBUS_NEW_IFACE_P2PDEVICE,
 				      "GroupFormationFailure");
@@ -2222,12 +2313,13 @@ void wpas_dbus_signal_p2p_group_formation_failure(struct wpa_supplicant *wpa_s,
  * @bssid: P2P Group BSSID or %NULL if not received
  * @id: Persistent group id or %0 if not persistent group
  * @op_freq: Operating frequency for the group
+ * @status : staus of our Invitation Response
  */
 
 void wpas_dbus_signal_p2p_invitation_received(struct wpa_supplicant *wpa_s,
 					      const u8 *sa, const u8 *dev_addr,
 					      const u8 *bssid, int id,
-					      int op_freq)
+					      int op_freq, int status)
 {
 	DBusMessage *msg;
 	DBusMessageIter iter, dict_iter;
@@ -2242,6 +2334,9 @@ void wpas_dbus_signal_p2p_invitation_received(struct wpa_supplicant *wpa_s,
 	if (wpa_s->p2p_mgmt)
 		wpa_s = wpa_s->parent;
 
+	if (!wpa_s->dbus_new_path)
+		return;
+
 	msg = dbus_message_new_signal(wpa_s->dbus_new_path,
 				      WPAS_DBUS_NEW_IFACE_P2PDEVICE,
 				      "InvitationReceived");
@@ -2250,6 +2345,7 @@ void wpas_dbus_signal_p2p_invitation_received(struct wpa_supplicant *wpa_s,
 
 	dbus_message_iter_init_append(msg, &iter);
 	if (!wpa_dbus_dict_open_write(&iter, &dict_iter) ||
+	    !wpa_dbus_dict_append_int32(&dict_iter, "status", status) ||
 	    (sa &&
 	     !wpa_dbus_dict_append_byte_array(&dict_iter, "sa",
 					      (const char *) sa, ETH_ALEN)) ||
@@ -3851,6 +3947,10 @@ static const struct wpa_dbus_property_desc wpas_dbus_interface_properties[] = {
 	  wpas_dbus_setter_p2p_device_config,
 	  NULL
 	},
+	{ "P2PDisabled", WPAS_DBUS_NEW_IFACE_P2PDEVICE, "b",
+	  wpas_dbus_getter_p2p_disabled,
+	  wpas_dbus_setter_p2p_disabled
+	},
 	{ "Peers", WPAS_DBUS_NEW_IFACE_P2PDEVICE, "ao",
 	  wpas_dbus_getter_p2p_peers,
 	  NULL,
@@ -4521,6 +4621,11 @@ static const struct wpa_dbus_property_desc wpas_dbus_p2p_peer_properties[] = {
 	  NULL,
 	  NULL
 	},
+	{ "SignalInfo", WPAS_DBUS_NEW_IFACE_INTERFACE, "a{sv}",
+	  wpas_dbus_getter_signal_info,
+	  NULL,
+	  NULL
+	},
 	{ NULL, NULL, NULL, NULL, NULL, NULL }
 };
 
@@ -4843,12 +4948,22 @@ static const struct wpa_dbus_signal_desc wpas_dbus_p2p_group_signals[] = {
 	{ "PeerJoined", WPAS_DBUS_NEW_IFACE_P2P_GROUP,
 	  {
 		  { "peer", "o", ARG_OUT },
+		  { "dev_addr", "s", ARG_OUT },
 		  END_ARGS
 	  }
 	},
 	{ "PeerDisconnected", WPAS_DBUS_NEW_IFACE_P2P_GROUP,
 	  {
 		  { "peer", "o", ARG_OUT },
+		  { "dev_addr", "s", ARG_OUT },
+		  END_ARGS
+	  }
+	},
+	{ "PeerJoinedWithIP", WPAS_DBUS_NEW_IFACE_P2P_GROUP,
+	  {
+		  { "peer", "o", ARG_OUT },
+		  { "ip_addr", "s", ARG_OUT },
+		  { "dev_addr", "s", ARG_OUT },
 		  END_ARGS
 	  }
 	},
diff --git a/wpa_supplicant/dbus/dbus_new.h b/wpa_supplicant/dbus/dbus_new.h
index 26bdcb548..b504c1be2 100644
--- a/wpa_supplicant/dbus/dbus_new.h
+++ b/wpa_supplicant/dbus/dbus_new.h
@@ -213,7 +213,7 @@ void wpas_dbus_signal_p2p_go_neg_req(struct wpa_supplicant *wpa_s,
 				     u8 go_intent);
 void wpas_dbus_signal_p2p_group_started(struct wpa_supplicant *wpa_s,
 					int client, int persistent,
-					const u8 *ip);
+					const u8 *ip, const u8 *go_dev_addr, int freq);
 void wpas_dbus_signal_p2p_group_formation_failure(struct wpa_supplicant *wpa_s,
 						  const char *reason);
 void wpas_dbus_register_p2p_group(struct wpa_supplicant *wpa_s,
@@ -229,7 +229,7 @@ int wpas_dbus_unregister_persistent_group(struct wpa_supplicant *wpa_s,
 void wpas_dbus_signal_p2p_invitation_result(struct wpa_supplicant *wpa_s,
 					    int status, const u8 *bssid);
 void wpas_dbus_signal_p2p_peer_disconnected(struct wpa_supplicant *wpa_s,
-					    const u8 *member);
+					    const u8 *member, const u8 *p2p_dev_addr);
 void wpas_dbus_signal_p2p_sd_request(struct wpa_supplicant *wpa_s,
 				     int freq, const u8 *sa, u8 dialog_token,
 				     u16 update_indic, const u8 *tlvs,
@@ -238,7 +238,7 @@ void wpas_dbus_signal_p2p_sd_response(struct wpa_supplicant *wpa_s,
 				      const u8 *sa, u16 update_indic,
 				      const u8 *tlvs, size_t tlvs_len);
 void wpas_dbus_signal_p2p_peer_joined(struct wpa_supplicant *wpa_s,
-				const u8 *member);
+				const u8 *member, const u8 *p2p_dev_addr);
 void wpas_dbus_signal_p2p_wps_failed(struct wpa_supplicant *wpa_s,
 				     struct wps_event_fail *fail);
 void wpas_dbus_signal_certification(struct wpa_supplicant *wpa_s,
@@ -259,7 +259,7 @@ void wpas_dbus_signal_sta_deauthorized(struct wpa_supplicant *wpa_s,
 void wpas_dbus_signal_p2p_invitation_received(struct wpa_supplicant *wpa_s,
 					      const u8 *sa, const u8 *dev_addr,
 					      const u8 *bssid, int id,
-					      int op_freq);
+					      int op_freq, int status);
 void wpas_dbus_signal_mesh_group_started(struct wpa_supplicant *wpa_s,
 					 struct wpa_ssid *ssid);
 void wpas_dbus_signal_mesh_group_removed(struct wpa_supplicant *wpa_s,
@@ -452,7 +452,7 @@ static inline void wpas_dbus_signal_p2p_go_neg_req(struct wpa_supplicant *wpa_s,
 static inline void
 wpas_dbus_signal_p2p_group_started(struct wpa_supplicant *wpa_s,
 				   int client, int persistent,
-				   const u8 *ip)
+				   const u8 *ip, const u8 *go_dev_addr, int freq)
 {
 }
 
@@ -526,7 +526,13 @@ wpas_dbus_unregister_p2p_groupmember(struct wpa_supplicant *wpa_s,
 
 static inline void
 wpas_dbus_signal_p2p_peer_joined(struct wpa_supplicant *wpa_s,
-				 const u8 *member)
+				 const u8 *member, const u8 *p2p_dev_addr)
+{
+}
+
+static inline void
+wpas_dbus_signal_p2p_peer_joined_with_ip(struct wpa_supplicant *wpa_s,
+				 const u8 *member, const u8 *p2p_dev_addr)
 {
 }
 
@@ -549,7 +555,7 @@ wpas_dbus_signal_peer_device_lost(struct wpa_supplicant *wpa_s,
 
 static inline void
 wpas_dbus_signal_p2p_peer_disconnected(struct wpa_supplicant *wpa_s,
-				       const u8 *member)
+				       const u8 *member, const u8 *p2p_dev_addr)
 {
 }
 
diff --git a/wpa_supplicant/dbus/dbus_new_handlers.c b/wpa_supplicant/dbus/dbus_new_handlers.c
index 959a68b4c..6a1a81591 100644
--- a/wpa_supplicant/dbus/dbus_new_handlers.c
+++ b/wpa_supplicant/dbus/dbus_new_handlers.c
@@ -3481,6 +3481,56 @@ dbus_bool_t wpas_dbus_getter_disconnect_reason(
 						&reason, error);
 }
 
+/**
+ * wpas_dbus_getter_signal_info - Get most recent signal information
+ * @iter: Pointer to incoming dbus message iter
+ * @error: Location to store error on failure
+ * @user_data: Function specific data
+ * Returns: TRUE on success, FALSE on failure
+ *
+ * Getter for "SignalInfo" property.
+ */
+dbus_bool_t wpas_dbus_getter_signal_info(
+	const struct wpa_dbus_property_desc *property_desc,
+	DBusMessageIter *iter, DBusError *error, void *user_data)
+{
+	struct wpa_supplicant *wpa_s = user_data;
+	struct wpa_signal_info si;
+	int ret;
+	DBusMessageIter variant_iter, dict_iter;
+
+	memset(&si, 0, sizeof(struct wpa_signal_info));
+
+	ret = wpa_drv_signal_poll(wpa_s, &si);
+	if (ret)
+		wpa_printf(MSG_DEBUG, "dbus: Failed to retrieve signal info from driver");
+
+	if (!dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT, "a{sv}", &variant_iter) ||
+	    !wpa_dbus_dict_open_write(&variant_iter, &dict_iter))
+		goto err_no_mem;
+
+	if (!wpa_dbus_dict_append_uint32(&dict_iter, "RSSI", si.current_signal))
+		goto err_no_mem;
+
+	if (!wpa_dbus_dict_append_uint32(&dict_iter, "LinkSpeed", si.current_txrate / 1000))
+		goto err_no_mem;
+
+	if (!wpa_dbus_dict_append_uint32(&dict_iter, "Noise", si.current_noise))
+		goto err_no_mem;
+
+	if (!wpa_dbus_dict_append_uint32(&dict_iter, "Frequency", si.frequency))
+		goto err_no_mem;
+
+	if (!wpa_dbus_dict_close_write(&variant_iter, &dict_iter) ||
+	    !dbus_message_iter_close_container(iter, &variant_iter))
+		goto err_no_mem;
+
+	return TRUE;
+
+err_no_mem:
+	dbus_set_error_const(error, DBUS_ERROR_NO_MEMORY, "no memory");
+	return FALSE;
+}
 
 /**
  * wpas_dbus_getter_auth_status_code - Get most recent auth status code
@@ -5507,6 +5557,12 @@ dbus_bool_t wpas_dbus_getter_network_properties(
 
 	iterator = props;
 	while (*iterator) {
+		if (!os_strcmp("ssid", *iterator))
+		{
+			wpa_dbus_dict_append_byte_array(&dict_iter, "binary-ssid",
+				net->ssid->ssid, net->ssid->ssid_len);
+		}
+
 		if (!wpa_dbus_dict_append_string(&dict_iter, *iterator,
 						 *(iterator + 1))) {
 			dbus_set_error_const(error, DBUS_ERROR_NO_MEMORY,
diff --git a/wpa_supplicant/dbus/dbus_new_handlers.h b/wpa_supplicant/dbus/dbus_new_handlers.h
index a421083f7..fc15ed81b 100644
--- a/wpa_supplicant/dbus/dbus_new_handlers.h
+++ b/wpa_supplicant/dbus/dbus_new_handlers.h
@@ -168,6 +168,7 @@ DECLARE_ACCESSOR(wpas_dbus_getter_disconnect_reason);
 DECLARE_ACCESSOR(wpas_dbus_getter_disassociate_reason);
 DECLARE_ACCESSOR(wpas_dbus_getter_auth_status_code);
 DECLARE_ACCESSOR(wpas_dbus_getter_assoc_status_code);
+DECLARE_ACCESSOR(wpas_dbus_getter_signal_info);
 DECLARE_ACCESSOR(wpas_dbus_getter_roam_time);
 DECLARE_ACCESSOR(wpas_dbus_getter_roam_complete);
 DECLARE_ACCESSOR(wpas_dbus_getter_session_length);
diff --git a/wpa_supplicant/dbus/dbus_new_handlers_p2p.c b/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
index de79178f4..75e9832c5 100644
--- a/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
+++ b/wpa_supplicant/dbus/dbus_new_handlers_p2p.c
@@ -1219,6 +1219,34 @@ dbus_bool_t wpas_dbus_setter_p2p_device_config(
 }
 
 
+dbus_bool_t wpas_dbus_getter_p2p_disabled(
+	const struct wpa_dbus_property_desc *property_desc,
+	DBusMessageIter *iter, DBusError *error, void *user_data)
+{
+	struct wpa_supplicant *wpa_s = user_data;
+	dbus_bool_t disabled = wpa_s->global->p2p_disabled ? TRUE : FALSE;
+
+	return wpas_dbus_simple_property_getter(iter, DBUS_TYPE_BOOLEAN,
+						&disabled, error);
+}
+
+dbus_bool_t wpas_dbus_setter_p2p_disabled(
+	const struct wpa_dbus_property_desc *property_desc,
+	DBusMessageIter *iter, DBusError *error, void *user_data)
+{
+	struct wpa_supplicant *wpa_s = user_data;
+	dbus_bool_t disabled;
+
+	if (!wpas_dbus_simple_property_setter(iter, error, DBUS_TYPE_BOOLEAN,
+					      &disabled))
+		return FALSE;
+
+	wpas_p2p_set_disabled(wpa_s, disabled ? 1 : 0);
+
+	return TRUE;
+}
+
+
 dbus_bool_t wpas_dbus_getter_p2p_peers(
 	const struct wpa_dbus_property_desc *property_desc,
 	DBusMessageIter *iter, DBusError *error, void *user_data)
@@ -1902,8 +1930,10 @@ static int match_group_where_peer_is_client(struct p2p_group *group,
 		goto out_of_memory;
 
 	data->paths = paths;
-	data->paths[data->nb_paths] = wpa_s_go->dbus_groupobj_path;
-	data->nb_paths++;
+	if (wpa_s_go->dbus_groupobj_path != NULL){
+		data->paths[data->nb_paths] = wpa_s_go->dbus_groupobj_path;
+		data->nb_paths++;
+	}
 
 	return 1;
 
diff --git a/wpa_supplicant/dbus/dbus_new_handlers_p2p.h b/wpa_supplicant/dbus/dbus_new_handlers_p2p.h
index b3c45c110..4cb7013c6 100644
--- a/wpa_supplicant/dbus/dbus_new_handlers_p2p.h
+++ b/wpa_supplicant/dbus/dbus_new_handlers_p2p.h
@@ -91,6 +91,8 @@ DBusMessage *wpas_dbus_handler_p2p_serv_disc_external(
  */
 DECLARE_ACCESSOR(wpas_dbus_setter_p2p_device_config);
 DECLARE_ACCESSOR(wpas_dbus_getter_p2p_device_config);
+DECLARE_ACCESSOR(wpas_dbus_getter_p2p_disabled);
+DECLARE_ACCESSOR(wpas_dbus_setter_p2p_disabled);
 DECLARE_ACCESSOR(wpas_dbus_getter_p2p_peers);
 DECLARE_ACCESSOR(wpas_dbus_getter_p2p_role);
 DECLARE_ACCESSOR(wpas_dbus_getter_p2p_group);
diff --git a/wpa_supplicant/notify.c b/wpa_supplicant/notify.c
index 821c916c1..8c1e782a8 100644
--- a/wpa_supplicant/notify.c
+++ b/wpa_supplicant/notify.c
@@ -616,6 +616,9 @@ void wpas_notify_p2p_device_found(struct wpa_supplicant *wpa_s,
 		wpas_dbus_register_peer(wpa_s, dev_addr);
 	}
 
+	if (wpa_s->global->p2p_disabled || wpa_s->global->p2p == NULL)
+		return;
+
 	/* Notify a new peer has been detected*/
 	wpas_dbus_signal_peer_device_found(wpa_s, dev_addr);
 }
@@ -708,12 +711,13 @@ void wpas_notify_p2p_provision_discovery(struct wpa_supplicant *wpa_s,
 
 void wpas_notify_p2p_group_started(struct wpa_supplicant *wpa_s,
 				   struct wpa_ssid *ssid, int persistent,
-				   int client, const u8 *ip)
+				   int client, const u8 *ip, const u8 *go_dev_addr, int freq)
 {
 	/* Notify a group has been started */
 	wpas_dbus_register_p2p_group(wpa_s, ssid);
 
-	wpas_dbus_signal_p2p_group_started(wpa_s, client, persistent, ip);
+	wpa_printf(MSG_INFO, "wpas_notify_p2p_group_started freq %d", freq);
+	wpas_dbus_signal_p2p_group_started(wpa_s, client, persistent, ip, go_dev_addr, freq);
 }
 
 
@@ -734,11 +738,11 @@ void wpas_notify_p2p_wps_failed(struct wpa_supplicant *wpa_s,
 
 void wpas_notify_p2p_invitation_received(struct wpa_supplicant *wpa_s,
 					 const u8 *sa, const u8 *go_dev_addr,
-					 const u8 *bssid, int id, int op_freq)
+					 const u8 *bssid, int id, int op_freq, int status)
 {
 	/* Notify a P2P Invitation Request */
 	wpas_dbus_signal_p2p_invitation_received(wpa_s, sa, go_dev_addr, bssid,
-						 id, op_freq);
+						 id, op_freq, status);
 }
 
 #endif /* CONFIG_P2P */
@@ -746,8 +750,11 @@ void wpas_notify_p2p_invitation_received(struct wpa_supplicant *wpa_s,
 
 static void wpas_notify_ap_sta_authorized(struct wpa_supplicant *wpa_s,
 					  const u8 *sta,
-					  const u8 *p2p_dev_addr)
+					  const u8 *p2p_dev_addr, const char *ip_addr)
 {
+//	if (!p2p_dev_addr)
+//		wpas_dbus_signal_ap_authorized(wpa_s);
+
 #ifdef CONFIG_P2P
 	wpas_p2p_notify_ap_sta_authorized(wpa_s, p2p_dev_addr);
 
@@ -755,8 +762,12 @@ static void wpas_notify_ap_sta_authorized(struct wpa_supplicant *wpa_s,
 	 * Create 'peer-joined' signal on group object -- will also
 	 * check P2P itself.
 	 */
-	if (p2p_dev_addr)
-		wpas_dbus_signal_p2p_peer_joined(wpa_s, p2p_dev_addr);
+	if (p2p_dev_addr) {
+		if (ip_addr == NULL)
+			wpas_dbus_signal_p2p_peer_joined(wpa_s, sta, p2p_dev_addr);
+		else
+			wpas_dbus_signal_p2p_peer_joined_with_ip(wpa_s, sta, ip_addr, p2p_dev_addr);
+	}
 #endif /* CONFIG_P2P */
 
 	/* Register the station */
@@ -776,8 +787,8 @@ static void wpas_notify_ap_sta_deauthorized(struct wpa_supplicant *wpa_s,
 	 * Create 'peer-disconnected' signal on group object if this
 	 * is a P2P group.
 	 */
-	if (p2p_dev_addr)
-		wpas_dbus_signal_p2p_peer_disconnected(wpa_s, p2p_dev_addr);
+	if(p2p_dev_addr)
+		wpas_dbus_signal_p2p_peer_disconnected(wpa_s, sta, p2p_dev_addr);
 #endif /* CONFIG_P2P */
 
 	/* Notify listeners a station has been deauthorized */
@@ -790,10 +801,10 @@ static void wpas_notify_ap_sta_deauthorized(struct wpa_supplicant *wpa_s,
 
 void wpas_notify_sta_authorized(struct wpa_supplicant *wpa_s,
 				const u8 *mac_addr, int authorized,
-				const u8 *p2p_dev_addr)
+				const u8 *p2p_dev_addr, const char *ip_addr)
 {
 	if (authorized)
-		wpas_notify_ap_sta_authorized(wpa_s, mac_addr, p2p_dev_addr);
+		wpas_notify_ap_sta_authorized(wpa_s, mac_addr, p2p_dev_addr, ip_addr);
 	else
 		wpas_notify_ap_sta_deauthorized(wpa_s, mac_addr, p2p_dev_addr);
 }
@@ -899,7 +910,6 @@ void wpas_notify_network_type_changed(struct wpa_supplicant *wpa_s,
 #endif /* CONFIG_P2P */
 }
 
-
 #ifdef CONFIG_MESH
 
 void wpas_notify_mesh_group_started(struct wpa_supplicant *wpa_s,
diff --git a/wpa_supplicant/notify.h b/wpa_supplicant/notify.h
index c46e7986e..c9c783dd9 100644
--- a/wpa_supplicant/notify.h
+++ b/wpa_supplicant/notify.h
@@ -92,7 +92,7 @@ void wpas_notify_resume(struct wpa_global *global);
 
 void wpas_notify_sta_authorized(struct wpa_supplicant *wpa_s,
 				const u8 *mac_addr, int authorized,
-				const u8 *p2p_dev_addr);
+				const u8 *p2p_dev_addr, const char *ip_addr);
 void wpas_notify_p2p_find_stopped(struct wpa_supplicant *wpa_s);
 void wpas_notify_p2p_device_found(struct wpa_supplicant *wpa_s,
 				  const u8 *dev_addr, int new_device);
@@ -121,7 +121,7 @@ void wpas_notify_p2p_provision_discovery(struct wpa_supplicant *wpa_s,
 					 unsigned int generated_pin);
 void wpas_notify_p2p_group_started(struct wpa_supplicant *wpa_s,
 				   struct wpa_ssid *ssid, int persistent,
-				   int client, const u8 *ip);
+				   int client, const u8 *ip, const u8 *go_dev_addr, int freq);
 void wpas_notify_p2p_group_formation_failure(struct wpa_supplicant *wpa_s,
 					     const char *reason);
 void wpas_notify_persistent_group_added(struct wpa_supplicant *wpa_s,
@@ -147,7 +147,7 @@ void wpas_notify_network_type_changed(struct wpa_supplicant *wpa_s,
 				      struct wpa_ssid *ssid);
 void wpas_notify_p2p_invitation_received(struct wpa_supplicant *wpa_s,
 					 const u8 *sa, const u8 *go_dev_addr,
-					 const u8 *bssid, int id, int op_freq);
+					 const u8 *bssid, int id, int op_freq, int status);
 void wpas_notify_mesh_group_started(struct wpa_supplicant *wpa_s,
 				    struct wpa_ssid *ssid);
 void wpas_notify_mesh_group_removed(struct wpa_supplicant *wpa_s,
diff --git a/wpa_supplicant/p2p_supplicant.c b/wpa_supplicant/p2p_supplicant.c
index ce44dfb9e..74d14f76d 100644
--- a/wpa_supplicant/p2p_supplicant.c
+++ b/wpa_supplicant/p2p_supplicant.c
@@ -1455,7 +1455,7 @@ static void wpas_group_formation_completed(struct wpa_supplicant *wpa_s,
 	}
 
 	if (!client) {
-		wpas_notify_p2p_group_started(wpa_s, ssid, persistent, 0, NULL);
+		wpas_notify_p2p_group_started(wpa_s, ssid, persistent, 0, NULL, go_dev_addr, ssid ? ssid->frequency : 0);
 		os_get_reltime(&wpa_s->global->p2p_go_wait_client);
 	}
 }
@@ -1890,7 +1890,7 @@ static void p2p_go_configured(void *ctx, void *data)
 
 		wpas_notify_p2p_group_started(wpa_s, ssid,
 					      params->persistent_group, 0,
-					      NULL);
+					      NULL, wpa_s->global->p2p_dev_addr, ssid->frequency);
 		wpas_p2p_cross_connect_setup(wpa_s);
 		wpas_p2p_set_group_idle_timeout(wpa_s);
 
@@ -2124,6 +2124,8 @@ static void wpas_start_wps_go(struct wpa_supplicant *wpa_s,
 	wpa_s->connect_without_scan = ssid;
 	wpa_s->reassociate = 1;
 	wpa_s->disconnected = 0;
+	wpa_dbg(wpa_s, MSG_DEBUG, "P2P: Disabling Extended Listen to start GO");
+	p2p_ext_listen(wpa_s->global->p2p, 0, 0);
 	wpa_dbg(wpa_s, MSG_DEBUG, "P2P: Request scan (that will be skipped) to "
 		"start GO)");
 	wpa_supplicant_req_scan(wpa_s, 0, 0);
@@ -3252,6 +3254,8 @@ static void wpas_invitation_received(void *ctx, const u8 *sa, const u8 *bssid,
 					       " persistent=%d",
 					       MAC2STR(sa), s->id);
 			}
+			wpas_notify_p2p_invitation_received(wpa_s, sa, go_dev_addr, bssid,
+					    s->id, op_freq, status);
 			wpas_p2p_group_add_persistent(
 				wpa_s, s, go, 0, op_freq, 0,
 				wpa_s->conf->p2p_go_ht40,
@@ -3269,6 +3273,8 @@ static void wpas_invitation_received(void *ctx, const u8 *sa, const u8 *bssid,
 				       " bssid=" MACSTR " unknown-network",
 				       MAC2STR(sa), MAC2STR(go_dev_addr),
 				       MAC2STR(bssid));
+			wpas_notify_p2p_invitation_received(wpa_s, sa, go_dev_addr,
+						    bssid, 0, op_freq, status);
 			wpas_p2p_join(wpa_s, bssid, go_dev_addr,
 				      wpa_s->p2p_wps_method, 0, op_freq,
 				      ssid, ssid_len);
@@ -3298,7 +3304,7 @@ static void wpas_invitation_received(void *ctx, const u8 *sa, const u8 *bssid,
 				       MAC2STR(sa), MAC2STR(go_dev_addr));
 		}
 		wpas_notify_p2p_invitation_received(wpa_s, sa, go_dev_addr,
-						    bssid, 0, op_freq);
+						    bssid, 0, op_freq, status);
 		return;
 	}
 
@@ -3312,7 +3318,7 @@ static void wpas_invitation_received(void *ctx, const u8 *sa, const u8 *bssid,
 			       MAC2STR(sa), s->id);
 	}
 	wpas_notify_p2p_invitation_received(wpa_s, sa, go_dev_addr, bssid,
-					    s->id, op_freq);
+					    s->id, op_freq, status);
 }
 
 
@@ -6906,6 +6912,8 @@ static int wpas_start_p2p_client(struct wpa_supplicant *wpa_s,
 	wpa_s->p2p_invite_go_freq = freq;
 	wpa_s->p2p_go_group_formation_completed = 0;
 	wpa_s->global->p2p_group_formation = wpa_s;
+	wpa_printf(MSG_DEBUG, "P2P: Diable Listen when start wps client");
+	p2p_ext_listen(wpa_s->global->p2p, 0, 0);
 
 	eloop_cancel_timeout(wpas_p2p_group_formation_timeout, wpa_s->p2pdev,
 			     NULL);
@@ -7385,6 +7393,10 @@ static void wpas_p2p_stop_find_oper(struct wpa_supplicant *wpa_s)
 
 void wpas_p2p_stop_find(struct wpa_supplicant *wpa_s)
 {
+
+	if (wpa_s == NULL)
+		return;
+
 	wpas_p2p_stop_find_oper(wpa_s);
 	if (!wpa_s->global->pending_group_iface_for_p2ps)
 		wpas_p2p_remove_pending_group_interface(wpa_s);
@@ -7788,7 +7800,7 @@ void wpas_p2p_completed(struct wpa_supplicant *wpa_s)
 		wpas_p2p_store_persistent_group(wpa_s->p2pdev,
 						ssid, go_dev_addr);
 
-	wpas_notify_p2p_group_started(wpa_s, ssid, persistent, 1, ip_ptr);
+	wpas_notify_p2p_group_started(wpa_s, ssid, persistent, 1, ip_ptr, go_dev_addr, freq);
 }
 
 
@@ -8837,13 +8849,19 @@ static void wpas_p2p_remove_client_go(struct wpa_supplicant *wpa_s,
 		sta = ap_get_sta(hapd, peer);
 	else
 		sta = ap_get_sta_p2p(hapd, peer);
+
 	if (sta) {
+		hapd->rejected_peer = os_malloc(ETH_ALEN);
+		os_memcpy(hapd->rejected_peer, sta->addr, ETH_ALEN);
 		wpa_dbg(wpa_s, MSG_DEBUG, "P2P: Disconnect peer " MACSTR
 			" (iface_addr=%d) from group",
 			MAC2STR(peer), iface_addr);
 		hostapd_drv_sta_deauth(hapd, sta->addr,
 				       WLAN_REASON_DEAUTH_LEAVING);
 		ap_sta_deauthenticate(hapd, sta, WLAN_REASON_DEAUTH_LEAVING);
+		eloop_cancel_timeout(clear_rejected_peer_timeout, hapd, NULL);
+		eloop_register_timeout(5, 0,
+					clear_rejected_peer_timeout, hapd, NULL);
 	}
 }
 
@@ -10105,3 +10123,22 @@ int wpas_p2p_lo_stop(struct wpa_supplicant *wpa_s)
 	wpa_s->p2p_lo_started = 0;
 	return ret;
 }
+
+
+int wpas_p2p_set_disabled(struct wpa_supplicant *wpa_s, int disable)
+{
+	wpa_s->global->p2p_disabled = disable;
+
+	wpa_printf(MSG_DEBUG, "P2P functionality %s",
+			   wpa_s->global->p2p_disabled ? "disabled" : "enabled");
+
+	if (wpa_s->global->p2p_disabled) {
+		wpas_p2p_stop_find(wpa_s);
+		os_memset(wpa_s->p2p_auth_invite, 0, ETH_ALEN);
+
+		if (wpa_s->global->p2p)
+			p2p_flush(wpa_s->global->p2p);
+	}
+
+	return 0;
+}
diff --git a/wpa_supplicant/p2p_supplicant.h b/wpa_supplicant/p2p_supplicant.h
index 5a869e730..9ff43557a 100644
--- a/wpa_supplicant/p2p_supplicant.h
+++ b/wpa_supplicant/p2p_supplicant.h
@@ -221,6 +221,7 @@ int wpas_p2p_lo_start(struct wpa_supplicant *wpa_s, unsigned int freq,
 		      unsigned int count);
 int wpas_p2p_lo_stop(struct wpa_supplicant *wpa_s);
 int wpas_p2p_mac_setup(struct wpa_supplicant *wpa_s);
+int wpas_p2p_set_disabled(struct wpa_supplicant *wpa_s, int disable);
 
 #else /* CONFIG_P2P */
 
diff --git a/wpa_supplicant/wpa_supplicant.c b/wpa_supplicant/wpa_supplicant.c
index d37a994f9..fbe4a762d 100644
--- a/wpa_supplicant/wpa_supplicant.c
+++ b/wpa_supplicant/wpa_supplicant.c
@@ -130,6 +130,7 @@ static void wpas_update_fils_connect_params(struct wpa_supplicant *wpa_s);
 static void wpas_update_owe_connect_params(struct wpa_supplicant *wpa_s);
 #endif /* CONFIG_OWE */
 
+static int prefer_channel = 0;
 
 #ifdef CONFIG_WEP
 /* Configure default/group WEP keys for static WEP */
@@ -8231,8 +8232,12 @@ int get_shared_radio_freqs_data(struct wpa_supplicant *wpa_s,
 		if (idx == len)
 			break;
 
-		if (ifs->current_ssid == NULL || ifs->assoc_freq == 0)
+		if (ifs->current_ssid == NULL || ifs->assoc_freq == 0) {
+			if(os_strcmp(ifs->ifname, "wlan0") == 0) {
+				prefer_channel = 0;
+			}
 			continue;
+		}
 
 		if (ifs->current_ssid->mode == WPAS_MODE_AP ||
 		    ifs->current_ssid->mode == WPAS_MODE_P2P_GO ||
@@ -8255,9 +8260,19 @@ int get_shared_radio_freqs_data(struct wpa_supplicant *wpa_s,
 			freqs_data[i].flags |= ifs->current_ssid->p2p_group ?
 				WPA_FREQ_USED_BY_P2P_CLIENT :
 				WPA_FREQ_USED_BY_INFRA_STATION;
+			if(!ifs->current_ssid->p2p_group) {
+				prefer_channel = freqs_data[i].freq;
+			}
 		}
 	}
 
+	if(prefer_channel) {
+		freqs_data[0].freq = prefer_channel;
+		freqs_data[0].flags |= WPA_FREQ_USED_BY_INFRA_STATION;
+		if(idx < len)
+			idx = 1;
+	}
+
 	dump_freq_data(wpa_s, "completed iteration", freqs_data, idx);
 	return idx;
 }

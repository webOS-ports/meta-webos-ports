From e114fec62adf13b8c21ca890fb748cb27f391c25 Mon Sep 17 00:00:00 2001
From: Thiago Macieira <thiago.macieira@intel.com>
Date: Wed, 8 Jun 2022 09:33:23 -0700
Subject: [PATCH] QJsonValue: fix incorrect to{Array,Object} when the value is
 empty

This is a repeat of commit de6ced66920600e659dbaa2509526a3bcb0b3360
"QCborValue: fix incorrect to{Array,Map} when the value is empty" (6.4),
which fixed the same thing for QCborValue. I've just copied the exact
same implementation onto the QJsonValue functions.

Pick-to: 6.2 6.3 6.4 5.15
Fixes: QTBUG-104085
Change-Id: I175efddd75f24ae59057fffd16f6b257bf7ed36d
Reviewed-by: Sona Kurazyan <sona.kurazyan@qt.io>
---
 src/corelib/serialization/qjsonarray.cpp      |  1 -
 src/corelib/serialization/qjsonobject.cpp     |  1 -
 src/corelib/serialization/qjsonvalue.cpp      | 22 ++++++++++++-------
 .../corelib/serialization/json/tst_qtjson.cpp | 18 +++++++++++++--
 4 files changed, 30 insertions(+), 12 deletions(-)

diff --git a/src/corelib/serialization/qjsonarray.cpp b/src/corelib/serialization/qjsonarray.cpp
index 94277db922..167b6a3a77 100644
--- a/src/corelib/serialization/qjsonarray.cpp
+++ b/src/corelib/serialization/qjsonarray.cpp
@@ -119,7 +119,6 @@ QJsonArray::QJsonArray() = default;
 QJsonArray::QJsonArray(QCborContainerPrivate *array)
     : a(array)
 {
-    Q_ASSERT(array);
 }
 
 /*!
diff --git a/src/corelib/serialization/qjsonobject.cpp b/src/corelib/serialization/qjsonobject.cpp
index ad217b419e..a3e5bd695e 100644
--- a/src/corelib/serialization/qjsonobject.cpp
+++ b/src/corelib/serialization/qjsonobject.cpp
@@ -103,7 +103,6 @@ QJsonObject::QJsonObject() = default;
 QJsonObject::QJsonObject(QCborContainerPrivate *object)
     : o(object)
 {
-    Q_ASSERT(o);
 }
 
 /*!
diff --git a/src/corelib/serialization/qjsonvalue.cpp b/src/corelib/serialization/qjsonvalue.cpp
index be982f82db..a92677d19d 100644
--- a/src/corelib/serialization/qjsonvalue.cpp
+++ b/src/corelib/serialization/qjsonvalue.cpp
@@ -708,11 +708,14 @@ QString QJsonValue::toString() const
  */
 QJsonArray QJsonValue::toArray(const QJsonArray &defaultValue) const
 {
-    const auto dd = QJsonPrivate::Value::container(value);
-    const auto n = QJsonPrivate::Value::valueHelper(value);
-    if (value.type() != QCborValue::Array || n >= 0 || !dd)
+    if (!isArray())
         return defaultValue;
-
+    QCborContainerPrivate *dd = nullptr;
+    const auto n = QJsonPrivate::Value::valueHelper(value);
+    const auto container = QJsonPrivate::Value::container(value);
+    Q_ASSERT(n == -1 || container == nullptr);
+    if (n < 0)
+        dd = container;
     return QJsonArray(dd);
 }
 
@@ -735,11 +738,14 @@ QJsonArray QJsonValue::toArray() const
  */
 QJsonObject QJsonValue::toObject(const QJsonObject &defaultValue) const
 {
-    const auto dd = QJsonPrivate::Value::container(value);
-    const auto n = QJsonPrivate::Value::valueHelper(value);
-    if (value.type() != QCborValue::Map || n >= 0 || !dd)
+    if (!isObject())
         return defaultValue;
-
+    QCborContainerPrivate *dd = nullptr;
+    const auto container = QJsonPrivate::Value::container(value);
+    const auto n = QJsonPrivate::Value::valueHelper(value);
+    Q_ASSERT(n == -1 || container == nullptr);
+    if (n < 0)
+        dd = container;
     return QJsonObject(dd);
 }
 
diff --git a/tests/auto/corelib/serialization/json/tst_qtjson.cpp b/tests/auto/corelib/serialization/json/tst_qtjson.cpp
index fe97e03690..7e01ca3f98 100644
--- a/tests/auto/corelib/serialization/json/tst_qtjson.cpp
+++ b/tests/auto/corelib/serialization/json/tst_qtjson.cpp
@@ -768,15 +768,20 @@ void tst_QtJson::testValueObject()
 void tst_QtJson::testValueArray()
 {
     QJsonArray array;
+    QJsonArray otherArray = {"wrong value"};
+    QJsonValue value(array);
+    QCOMPARE(value.toArray(), array);
+    QCOMPARE(value.toArray(otherArray), array);
+
     array.append(999.);
     array.append(QLatin1String("test"));
     array.append(true);
-
-    QJsonValue value(array);
+    value = array;
 
     // if we don't modify the original JsonArray, toArray()
     // on the JsonValue should return the same object (non-detached).
     QCOMPARE(value.toArray(), array);
+    QCOMPARE(value.toArray(otherArray), array);
 
     // if we modify the original array, it should detach
     array.append(QLatin1String("test"));
@@ -786,14 +791,23 @@ void tst_QtJson::testValueArray()
 void tst_QtJson::testObjectNested()
 {
     QJsonObject inner, outer;
+    QJsonObject otherObject = {{"wrong key", "wrong value"}};
+    QJsonValue v = inner;
+    QCOMPARE(v.toObject(), inner);
+    QCOMPARE(v.toObject(otherObject), inner);
+
     inner.insert("number", 999.);
     outer.insert("nested", inner);
 
     // if we don't modify the original JsonObject, value()
     // should return the same object (non-detached).
     QJsonObject value = outer.value("nested").toObject();
+    v = value;
     QCOMPARE(value, inner);
     QCOMPARE(value.value("number").toDouble(), 999.);
+    QCOMPARE(v.toObject(), inner);
+    QCOMPARE(v.toObject(otherObject), inner);
+    QCOMPARE(v["number"].toDouble(), 999.);
 
     // if we modify the original object, it should detach and not
     // affect the nested object
-- 
2.34.1


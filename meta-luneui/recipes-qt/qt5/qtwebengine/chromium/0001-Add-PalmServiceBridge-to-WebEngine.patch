From 39174198cc19e089515c150f66c3ed83461d160b Mon Sep 17 00:00:00 2001
From: Christophe Chapuis <chris.chapuis@gmail.com>
Date: Sat, 26 Sep 2015 22:26:24 +0200
Subject: [PATCH] Add PalmServiceBridge to WebEngine

* Adapt PalmServiceBridge IDL for Chromium
* Propagate PalmBridgeService related settings from host
* Attempt to have a correct implementation for onserviceresponse attribute
* test returned identifier before using it
* PalmServiceBridge: adapt to Chromium 53 code base
* PalmServiceBridge.idl: drop DependentLifetime because now it fails with:
  Unknown extended attribute [DependentLifetime]
* idl_definitions.py remove the blacklisting, because we still need to use
  ServiceCallback attribute

Signed-off-by: Christophe Chapuis <chris.chapuis@gmail.com>
Signed-off-by: Martin Jansa <Martin.Jansa@gmail.com>
---
 .../common/common_param_traits_macros.h       |   3 +
 .../content/public/common/web_preferences.cc  |   3 +
 .../content/public/common/web_preferences.h   |   5 +
 chromium/content/renderer/render_view_impl.cc |   3 +
 .../Source/bindings/modules/v8/generated.gni  |   2 +
 .../bindings/scripts/idl_definitions.py       |   2 -
 .../Source/core/exported/WebSettingsImpl.cpp  |  16 +
 .../Source/core/exported/WebSettingsImpl.h    |   3 +
 .../WebKit/Source/core/frame/Settings.json5   |  21 ++
 .../WebKit/Source/modules/BUILD.gn            |   1 +
 .../Source/modules/modules_idl_files.gni      |   1 +
 .../WebKit/Source/modules/webos/BUILD.gn      |  27 ++
 .../WebKit/Source/modules/webos/Logging.h     |  11 +
 .../Source/modules/webos/LunaServiceMgr.cpp   | 314 ++++++++++++++++++
 .../Source/modules/webos/LunaServiceMgr.h     |  53 +++
 .../modules/webos/PalmServiceBridge.cpp       | 283 ++++++++++++++++
 .../Source/modules/webos/PalmServiceBridge.h  |  92 +++++
 .../modules/webos/PalmServiceBridge.idl       |  14 +
 .../WebKit/public/web/WebSettings.h           |   3 +
 19 files changed, 855 insertions(+), 2 deletions(-)
 create mode 100644 chromium/third_party/WebKit/Source/modules/webos/BUILD.gn
 create mode 100644 chromium/third_party/WebKit/Source/modules/webos/Logging.h
 create mode 100644 chromium/third_party/WebKit/Source/modules/webos/LunaServiceMgr.cpp
 create mode 100644 chromium/third_party/WebKit/Source/modules/webos/LunaServiceMgr.h
 create mode 100644 chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.cpp
 create mode 100644 chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.h
 create mode 100644 chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.idl

diff --git a/chromium/content/public/common/common_param_traits_macros.h b/chromium/content/public/common/common_param_traits_macros.h
index add74dc993..98e4eb471d 100644
--- a/chromium/content/public/common/common_param_traits_macros.h
+++ b/chromium/content/public/common/common_param_traits_macros.h
@@ -241,6 +241,9 @@ IPC_STRUCT_TRAITS_BEGIN(content::WebPreferences)
   IPC_STRUCT_TRAITS_MEMBER(do_not_update_selection_on_mutating_selection_range)
   IPC_STRUCT_TRAITS_MEMBER(autoplay_policy)
   IPC_STRUCT_TRAITS_MEMBER(low_priority_iframes_threshold)
+  IPC_STRUCT_TRAITS_MEMBER(luneosPriviledged)
+  IPC_STRUCT_TRAITS_MEMBER(palmServiceBridgeEnabled)
+  IPC_STRUCT_TRAITS_MEMBER(luneosAppIdentifier)
 IPC_STRUCT_TRAITS_END()
 
 IPC_STRUCT_TRAITS_BEGIN(blink::mojom::WindowFeatures)
diff --git a/chromium/content/public/common/web_preferences.cc b/chromium/content/public/common/web_preferences.cc
index a8d1c1b354..1bbf5bc8d5 100644
--- a/chromium/content/public/common/web_preferences.cc
+++ b/chromium/content/public/common/web_preferences.cc
@@ -241,6 +241,9 @@ WebPreferences::WebPreferences()
       autoplay_policy(AutoplayPolicy::kNoUserGestureRequired),
 #endif
       low_priority_iframes_threshold(net::EFFECTIVE_CONNECTION_TYPE_UNKNOWN) {
+      luneosPriviledged(false),
+      palmServiceBridgeEnabled(false),
+      luneosAppIdentifier("") {
   standard_font_family_map[kCommonScript] =
       base::ASCIIToUTF16("Times New Roman");
   fixed_font_family_map[kCommonScript] = base::ASCIIToUTF16("Courier New");
diff --git a/chromium/content/public/common/web_preferences.h b/chromium/content/public/common/web_preferences.h
index 1c2f3615c8..8f782de58b 100644
--- a/chromium/content/public/common/web_preferences.h
+++ b/chromium/content/public/common/web_preferences.h
@@ -304,6 +304,11 @@ struct CONTENT_EXPORT WebPreferences {
   // lowest priority.
   net::EffectiveConnectionType low_priority_iframes_threshold;
 
+  // Follwing settings are for LuneOS usage
+  bool luneosPriviledged;
+  bool palmServiceBridgeEnabled;
+  std::string luneosAppIdentifier;
+  
   // We try to keep the default values the same as the default values in
   // chrome, except for the cases where it would require lots of extra work for
   // the embedder to use the same default value.
diff --git a/chromium/content/renderer/render_view_impl.cc b/chromium/content/renderer/render_view_impl.cc
index aed014fd1b..631f97e6d8 100644
--- a/chromium/content/renderer/render_view_impl.cc
+++ b/chromium/content/renderer/render_view_impl.cc
@@ -952,6 +952,9 @@ void RenderView::ApplyWebPreferences(const WebPreferences& prefs,
 #else   // defined(OS_ANDROID)
   settings->SetFullscreenSupported(prefs.fullscreen_supported);
 #endif  // defined(OS_ANDROID)
+  settings->SetLuneosPriviledged(prefs.luneosPriviledged);
+  settings->SetPalmServiceBridgeEnabled(prefs.palmServiceBridgeEnabled);
+  settings->SetLuneosAppIdentifier(base::ASCIIToUTF16(prefs.luneosAppIdentifier));
 
   switch (prefs.autoplay_policy) {
     case AutoplayPolicy::kNoUserGestureRequired:
diff --git a/chromium/third_party/WebKit/Source/bindings/modules/v8/generated.gni b/chromium/third_party/WebKit/Source/bindings/modules/v8/generated.gni
index 29b0f62eca..0d45296aec 100644
--- a/chromium/third_party/WebKit/Source/bindings/modules/v8/generated.gni
+++ b/chromium/third_party/WebKit/Source/bindings/modules/v8/generated.gni
@@ -62,6 +62,8 @@ bindings_modules_generated_union_type_files = [
   "$bindings_modules_v8_output_dir/rendering_context.h",
   "$bindings_modules_v8_output_dir/request_or_usv_string_or_request_or_usv_string_sequence.cc",
   "$bindings_modules_v8_output_dir/request_or_usv_string_or_request_or_usv_string_sequence.h",
+  "$bindings_modules_v8_output_dir/service_callback.cpp",
+  "$bindings_modules_v8_output_dir/service_callback.h",
   "$bindings_modules_v8_output_dir/string_or_array_buffer_or_nfc_message.cc",
   "$bindings_modules_v8_output_dir/string_or_array_buffer_or_nfc_message.h",
   "$bindings_modules_v8_output_dir/string_or_canvas_gradient_or_canvas_pattern.cc",
diff --git a/chromium/third_party/WebKit/Source/bindings/scripts/idl_definitions.py b/chromium/third_party/WebKit/Source/bindings/scripts/idl_definitions.py
index f2f0e543e3..392604cbea 100644
--- a/chromium/third_party/WebKit/Source/bindings/scripts/idl_definitions.py
+++ b/chromium/third_party/WebKit/Source/bindings/scripts/idl_definitions.py
@@ -326,8 +326,6 @@ class IdlInterface(object):
             child_class = child.GetClass()
             if child_class == 'Attribute':
                 attr = IdlAttribute(child)
-                if is_blacklisted_attribute_type(attr.idl_type):
-                    raise ValueError('Type "%s" cannot be used as an attribute.' % attr.idl_type)
                 if attr.idl_type.is_integer_type and attr.name == 'length':
                     has_integer_typed_length = True
                 self.attributes.append(attr)
diff --git a/chromium/third_party/WebKit/Source/core/exported/WebSettingsImpl.cpp b/chromium/third_party/WebKit/Source/core/exported/WebSettingsImpl.cpp
index 88b347207e..19bac891e4 100644
--- a/chromium/third_party/WebKit/Source/core/exported/WebSettingsImpl.cpp
+++ b/chromium/third_party/WebKit/Source/core/exported/WebSettingsImpl.cpp
@@ -710,4 +710,20 @@ void WebSettingsImpl::SetLowPriorityIframesThreshold(
   settings_->SetLowPriorityIframesThreshold(effective_connection_type);
 }
 
+// LuneOS specific settings
+void WebSettingsImpl::SetLuneosAppIdentifier(const WebString& appId)
+{
+    settings_->SetLuneosAppIdentifier(appId);
+}
+
+void WebSettingsImpl::SetLuneosPriviledged(bool enabled)
+{
+    settings_->SetLuneosPriviledged(enabled);
+}
+
+void WebSettingsImpl::SetPalmServiceBridgeEnabled(bool enabled)
+{
+    settings_->SetPalmServiceBridgeEnabled(enabled);
+}
+
 }  // namespace blink
diff --git a/chromium/third_party/WebKit/Source/core/exported/WebSettingsImpl.h b/chromium/third_party/WebKit/Source/core/exported/WebSettingsImpl.h
index 9c2447112a..1e73125dc1 100644
--- a/chromium/third_party/WebKit/Source/core/exported/WebSettingsImpl.h
+++ b/chromium/third_party/WebKit/Source/core/exported/WebSettingsImpl.h
@@ -113,6 +113,8 @@ class CORE_EXPORT WebSettingsImpl final : public WebSettings {
   void SetProgressBarCompletion(ProgressBarCompletion) override;
   void SetSavePreviousDocumentResources(SavePreviousDocumentResources) override;
   void SetLocalStorageEnabled(bool) override;
+  void SetLuneosAppIdentifier(const WebString&) override;
+  void SetLuneosPriviledged(bool) override;
   void SetMainFrameClipsContent(bool) override;
   void SetMainFrameResizesAreOrientationChanges(bool) override;
   void SetMaxTouchPoints(int) override;
@@ -126,6 +128,7 @@ class CORE_EXPORT WebSettingsImpl final : public WebSettings {
   void SetMockScrollbarsEnabled(bool) override;
   void SetHideScrollbars(bool) override;
   void SetOfflineWebApplicationCacheEnabled(bool) override;
+  void SetPalmServiceBridgeEnabled(bool) override;
   void SetPassiveEventListenerDefault(PassiveEventListenerDefault) override;
   void SetPasswordEchoDurationInSeconds(double) override;
   void SetPasswordEchoEnabled(bool) override;
diff --git a/chromium/third_party/WebKit/Source/core/frame/Settings.json5 b/chromium/third_party/WebKit/Source/core/frame/Settings.json5
index 26091ba8de..58dbffe81f 100644
--- a/chromium/third_party/WebKit/Source/core/frame/Settings.json5
+++ b/chromium/third_party/WebKit/Source/core/frame/Settings.json5
@@ -845,6 +845,27 @@
       type: "PassiveListenerDefault",
     },
 
+    // LuneOS specific #####
+
+    // Whether PalmBridge is enabled or not
+    {
+      name: "palmServiceBridgeEnabled",
+      initial: false,
+    },
+
+    // Whether the LuneOS app has priviledge access
+    {
+      name: "luneosPriviledged",
+      initial: false,
+    },
+
+    // LuneOS app identifier
+    { 
+      name: "luneosAppIdentifier",
+      initial: "\"\"",
+      type: "String",
+    },
+
     // Whether the CSSPreloadScanner is used for externally CSS preloads. NoPreload
     // indicates that the scanner will be used, but no preloads issued.
     {
diff --git a/chromium/third_party/WebKit/Source/modules/BUILD.gn b/chromium/third_party/WebKit/Source/modules/BUILD.gn
index d33e591663..d3fa6ccb8a 100644
--- a/chromium/third_party/WebKit/Source/modules/BUILD.gn
+++ b/chromium/third_party/WebKit/Source/modules/BUILD.gn
@@ -153,6 +153,7 @@ target("jumbo_" + modules_target_type, "modules") {
     "//third_party/WebKit/Source/modules/vr",
     "//third_party/WebKit/Source/modules/wake_lock",
     "//third_party/WebKit/Source/modules/webaudio",
+    "//third_party/WebKit/Source/modules/webos",
     "//third_party/WebKit/Source/modules/webdatabase",
     "//third_party/WebKit/Source/modules/webgl",
     "//third_party/WebKit/Source/modules/webmidi",
diff --git a/chromium/third_party/WebKit/Source/modules/modules_idl_files.gni b/chromium/third_party/WebKit/Source/modules/modules_idl_files.gni
index 7f9dee7f33..b4feb6d271 100644
--- a/chromium/third_party/WebKit/Source/modules/modules_idl_files.gni
+++ b/chromium/third_party/WebKit/Source/modules/modules_idl_files.gni
@@ -394,6 +394,7 @@ modules_idl_files =
           "webmidi/MIDIOutput.idl",
           "webmidi/MIDIOutputMap.idl",
           "webmidi/MIDIPort.idl",
+          "webos/PalmServiceBridge.idl",
           "websockets/CloseEvent.idl",
           "websockets/WebSocket.idl",
           "webusb/USB.idl",
diff --git a/chromium/third_party/WebKit/Source/modules/webos/BUILD.gn b/chromium/third_party/WebKit/Source/modules/webos/BUILD.gn
new file mode 100644
index 0000000000..2da44924dc
--- /dev/null
+++ b/chromium/third_party/WebKit/Source/modules/webos/BUILD.gn
@@ -0,0 +1,27 @@
+# Copyright 2017 Herman van Hazendonk. All rights reserved.
+
+import("//third_party/WebKit/Source/modules/modules.gni")
+import("//build/config/linux/pkg_config.gni")
+
+pkg_config("ls2") {
+  packages = [ "luna-service2", "glib-2.0" ]
+}  
+
+blink_modules_sources("webos") {
+  sources = [
+    "Logging.h",
+    "LunaServiceMgr.cpp",
+    "LunaServiceMgr.h",
+    "PalmServiceBridge.cpp",
+    "PalmServiceBridge.h",
+  ]
+   
+  public_configs = [
+    ":ls2",
+  ]
+  
+  libs = [
+    "PmLogLib",   
+  ]
+
+}
diff --git a/chromium/third_party/WebKit/Source/modules/webos/Logging.h b/chromium/third_party/WebKit/Source/modules/webos/Logging.h
new file mode 100644
index 0000000000..d472ae299d
--- /dev/null
+++ b/chromium/third_party/WebKit/Source/modules/webos/Logging.h
@@ -0,0 +1,11 @@
+#ifndef LOGGING_H_
+#define LOGGING_H_
+
+#include <PmLogLib.h>
+
+extern PmLogContext LogContext;
+
+#define DEBUG(...) \
+	PmLogDebug(LogContext, ##__VA_ARGS__)
+
+#endif
diff --git a/chromium/third_party/WebKit/Source/modules/webos/LunaServiceMgr.cpp b/chromium/third_party/WebKit/Source/modules/webos/LunaServiceMgr.cpp
new file mode 100644
index 0000000000..f4b9f609e7
--- /dev/null
+++ b/chromium/third_party/WebKit/Source/modules/webos/LunaServiceMgr.cpp
@@ -0,0 +1,314 @@
+#include "base/message_loop/message_loop.h"
+#include "base/bind.h"
+
+#include <glib.h>
+#include "LunaServiceMgr.h"
+#include "Logging.h"
+
+#include <unistd.h>
+#include <lunaservice.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <wtf/text/WTFString.h>
+#include <wtf/text/CString.h>
+
+namespace blink {
+
+/**
+* @brief Internal callback for service responses.
+*
+* @param  sh
+* @param  reply
+* @param  ctx
+*
+* @retval
+*/
+static bool
+message_filter(LSHandle *sh, LSMessage* reply, void* ctx)
+{
+    const char* payload = LSMessageGetPayload(reply);
+
+    LunaServiceManagerListener* listener = (LunaServiceManagerListener*)ctx;
+
+    if (listener) {
+        listener->serviceResponse(payload);
+        return true;
+    }
+
+    return false;
+}
+
+bool doIterateNext = true;
+void GMainContextIterate()
+{
+    g_main_context_iteration(g_main_context_default(), false);
+    // be called again in 100ms
+    base::MessageLoop *pCurrentMsgLoop = base::MessageLoop::current();
+    if( doIterateNext && pCurrentMsgLoop )
+    {
+        pCurrentMsgLoop->task_runner()->PostDelayedTask(FROM_HERE, base::Bind(&GMainContextIterate), base::TimeDelta::FromMilliseconds(100));
+    }
+}
+
+LunaServiceManager* s_instance = 0;
+
+/**
+* @brief Obtains the singleton LunaServiceManager.
+*
+* @retval the LunaServiceManager
+*/
+LunaServiceManager* LunaServiceManager::instance()
+{
+    bool retVal;
+    if (s_instance)
+        return s_instance;
+
+    s_instance = new LunaServiceManager();
+    retVal = s_instance->init();
+    if (!retVal)
+        goto error;
+
+    return s_instance;
+
+error:
+    fprintf(stderr, "*******************************************************************\n");
+    fprintf(stderr, "*  Could got get an instance of LunaServiceManager.               *\n");
+    fprintf(stderr, "*  Try running with luna-dbus start; luna-dbus run <executable>.  *\n");
+    fprintf(stderr, "*******************************************************************\n");
+    exit(-1);
+}
+
+/**
+* @brief Private constructor to enforce singleton.
+*/
+LunaServiceManager::LunaServiceManager() :
+      publicBus(0)
+    , privateBus(0)
+    , palmServiceHandle(0)
+    , publicBusHighPriority(0)
+    , privateBusHighPriority(0)
+    , palmServiceHandleHighPriority(0)
+{
+}
+
+LunaServiceManager::~LunaServiceManager()
+{
+    doIterateNext = false;
+    // ED : Close the single connection to DBUS.
+    if (palmServiceHandle) {
+        bool retVal;
+        LSError lserror;
+        LSErrorInit(&lserror);
+
+        retVal = LSUnregisterPalmService(palmServiceHandle, &lserror);
+        if (!retVal) {
+            g_warning("LSUnregisterPalmService ERROR %d: %s (%s @ %s:%d)",
+                lserror.error_code, lserror.message,
+                lserror.func, lserror.file, lserror.line);
+            LSErrorFree(&lserror);
+        }
+    }
+}
+
+bool LunaServiceManager::init()
+{
+    bool init;
+    LSError lserror;
+    LSErrorInit(&lserror);
+
+    DEBUG("LunaServiceManager: Starting iteration on GLib event loop ...");
+    GMainContextIterate();
+
+    DEBUG("LunaServiceManager: initializing ...");
+
+    String id("com.palm.luna-");
+    id.append(String::number(getpid()));
+    String active = (id + "-active");
+    String phone = (id + "-phone");
+    init = LSRegisterPalmService(id.utf8().data(), &palmServiceHandle, &lserror);
+    if (!init)
+        goto error;
+
+    init = LSGmainAttachPalmService(palmServiceHandle,
+            g_main_loop_new(g_main_context_default(), TRUE), &lserror);
+    if (!init)
+        goto error;
+
+    privateBus = LSPalmServiceGetPrivateConnection(palmServiceHandle);
+    publicBus = LSPalmServiceGetPublicConnection(palmServiceHandle);
+
+    if (privateBus) {
+        init = LSGmainSetPriority(privateBus, G_PRIORITY_DEFAULT, &lserror);
+        if (!init)
+            goto error;
+    }
+
+    if (publicBus) {
+        init = LSGmainSetPriority(publicBus, G_PRIORITY_DEFAULT, &lserror);
+        if (!init)
+            goto error;
+    }
+
+    init = LSRegisterPalmService(phone.utf8().data(), &palmServiceHandleHighPriority, &lserror);
+    if (!init)
+        goto error;
+
+    init = LSGmainAttachPalmService(palmServiceHandleHighPriority,
+            g_main_loop_new(g_main_context_default(), TRUE), &lserror);
+    if (!init)
+        goto error;
+
+    privateBusHighPriority = LSPalmServiceGetPrivateConnection(palmServiceHandleHighPriority);
+    publicBusHighPriority = LSPalmServiceGetPublicConnection(palmServiceHandleHighPriority);
+
+    if (privateBusHighPriority) {
+        init = LSGmainSetPriority(privateBusHighPriority, G_PRIORITY_HIGH, &lserror);
+        if (!init)
+            goto error;
+    }
+
+    if (publicBusHighPriority) {
+        init = LSGmainSetPriority(publicBusHighPriority, G_PRIORITY_HIGH, &lserror);
+        if (!init)
+            goto error;
+    }
+
+
+    init = LSRegisterPalmService(active.utf8().data(), &palmServiceHandleMediumPriority, &lserror);
+    if (!init)
+        goto error;
+
+    init = LSGmainAttachPalmService(palmServiceHandleMediumPriority,
+            g_main_loop_new(g_main_context_default(), TRUE), &lserror);
+    if (!init)
+        goto error;
+
+    privateBusMediumPriority = LSPalmServiceGetPrivateConnection(palmServiceHandleMediumPriority);
+    publicBusMediumPriority = LSPalmServiceGetPublicConnection(palmServiceHandleMediumPriority);
+
+    if (privateBusMediumPriority) {
+        init = LSGmainSetPriority(privateBusMediumPriority, G_PRIORITY_HIGH + 50, &lserror);
+        if (!init)
+            goto error;
+    }
+
+    if (publicBusMediumPriority) {
+        init = LSGmainSetPriority(publicBusMediumPriority, G_PRIORITY_HIGH + 50, &lserror);
+        if (!init)
+            goto error;
+    }
+
+error:
+    if (!init) {
+        g_warning("Cannot initialize LunaServiceManager ERROR %d: %s (%s @ %s:%d)",
+            lserror.error_code, lserror.message,
+            lserror.func, lserror.file, lserror.line);
+        LSErrorFree(&lserror);
+    }
+
+    return init;
+}
+
+/**
+* @brief This method will make the async call to DBUS.
+*
+* @param  uri
+* @param  payload
+* @param  inListener
+*
+* @retval 0 if message could not be sent.
+* @retval >0 serial number for the message.
+*/
+unsigned long LunaServiceManager::call(const char* uri, const char* payload, LunaServiceManagerListener* inListener,
+                                       const char* callerId, bool usePrivateBus)
+{
+    bool retVal;
+    LSError lserror;
+    LSErrorInit(&lserror);
+    LSMessageToken token = 0;
+    LSHandle* serviceHandle = 0;
+
+    DEBUG("LunaServiceManager: calling %s payload %s inListener %p callerId %s usePrivateBus %d",
+          uri, payload, inListener, callerId, usePrivateBus);
+
+    if (callerId && (!(*callerId)))
+        callerId = 0;
+
+    static int phoneAppIdLen = strlen("com.palm.app.phone");
+    if (callerId && !(strncmp(callerId, "com.palm.app.phone", phoneAppIdLen))) {
+
+        if (!usePrivateBus)
+            serviceHandle = publicBusHighPriority;
+        else
+            serviceHandle = privateBusHighPriority;
+
+    } else {
+/*  else if (callerId && activeAppId && strncmp(callerId, activeAppId, strlen(activeAppId)) == 0) {
+
+
+        if (!usePrivateBus)
+            serviceHandle = publicBusMediumPriority;
+        else
+            serviceHandle = privateBusMediumPriority;
+    }
+*/
+        if (!usePrivateBus)
+            serviceHandle = publicBus;
+        else
+            serviceHandle = privateBus;
+    }
+
+    if (!inListener)
+        retVal = LSCallFromApplication(serviceHandle, uri, payload, callerId, 0, 0, &token, &lserror);
+    else {
+        retVal = LSCallFromApplication(serviceHandle, uri, payload, callerId, message_filter, inListener, &token, &lserror);
+        if (retVal) {
+            inListener->listenerToken = token;
+            inListener->sh = serviceHandle;
+        }
+    }
+
+    if (!retVal) {
+        g_warning("LSCallFromApplication ERROR %d: %s (%s @ %s:%d)",
+            lserror.error_code, lserror.message,
+            lserror.func, lserror.file, lserror.line);
+        LSErrorFree(&lserror);
+        token = 0;
+        goto error;
+    }
+
+error:
+    return token;
+}
+
+/**
+ * @brief Terminates a call causing any subscription for responses to end.
+ *        This is also called by garbage collector's collect()
+ *        when no more references to inListener exist.
+ *
+ * @param  inListener
+ */
+void LunaServiceManager::cancel(LunaServiceManagerListener* inListener)
+{
+    bool retVal;
+    LSError lserror;
+
+    if (!inListener || !inListener->listenerToken)
+        return;
+
+    DEBUG("LunaServiceManager: canceling call inListener %p", inListener);
+
+    LSErrorInit(&lserror);
+
+    if (!LSCallCancel(inListener->sh, inListener->listenerToken, &lserror)) {
+        g_warning("LSCallCancel ERROR %d: %s (%s @ %s:%d)",
+            lserror.error_code, lserror.message,
+            lserror.func, lserror.file, lserror.line);
+        LSErrorFree(&lserror);
+    }
+
+    // set the token to zero to indicate we have been canceled
+    inListener->listenerToken = 0;
+}
+};
diff --git a/chromium/third_party/WebKit/Source/modules/webos/LunaServiceMgr.h b/chromium/third_party/WebKit/Source/modules/webos/LunaServiceMgr.h
new file mode 100644
index 0000000000..d167f70e95
--- /dev/null
+++ b/chromium/third_party/WebKit/Source/modules/webos/LunaServiceMgr.h
@@ -0,0 +1,53 @@
+
+#ifndef LunaServiceMgr_h
+#define LunaServiceMgr_h
+
+#include <lunaservice.h>
+
+namespace blink {
+
+struct LunaServiceManagerListener {
+        LunaServiceManagerListener() : listenerToken(LSMESSAGE_TOKEN_INVALID), sh(0) { }
+        virtual ~LunaServiceManagerListener() { }
+        virtual void serviceResponse(const char* body) = 0;
+        LSMessageToken listenerToken;
+        LSHandle* sh;
+};
+
+
+//
+//  LunaServiceManager
+//
+// This class is a singleton which handles all the client requests
+// for a WebKit instance.
+
+class LunaServiceManager {
+    public:
+        ~LunaServiceManager();
+
+        static LunaServiceManager* instance();
+        unsigned long call(const char* uri, const char* payload, LunaServiceManagerListener*, const char* callerId, bool usePrivateBus = false);
+        void cancel(LunaServiceManagerListener*);
+
+    private:
+        bool init();
+        LunaServiceManager();
+
+        LSHandle* publicBus;
+        LSHandle* privateBus;
+        LSPalmService* palmServiceHandle;
+
+        // The Medium Priority bus is used for the active app
+        LSHandle* publicBusMediumPriority;
+        LSHandle* privateBusMediumPriority;
+        LSPalmService* palmServiceHandleMediumPriority;
+
+        // The High Priority bus is used only for the Phone app
+        LSHandle* publicBusHighPriority;
+        LSHandle* privateBusHighPriority;
+        LSPalmService* palmServiceHandleHighPriority;
+};
+
+}
+
+#endif
diff --git a/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.cpp b/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.cpp
new file mode 100644
index 0000000000..b6ece79d4f
--- /dev/null
+++ b/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.cpp
@@ -0,0 +1,283 @@
+#include "PalmServiceBridge.h"
+#include "Logging.h"
+
+#include "core/dom/Document.h"
+#include "core/events/Event.h"
+#include "core/dom/ExceptionCode.h"
+#include "core/frame/Frame.h"
+#include "core/page/Page.h"
+#include "core/frame/Settings.h"
+#include <wtf/text/WTFString.h>
+#include "bindings/core/v8/ScriptSourceCode.h"
+#include "bindings/core/v8/ScriptController.h"
+#include "bindings/core/v8/ScriptState.h"
+#include "bindings/core/v8/V8Binding.h"
+#include "bindings/core/v8/ExceptionState.h"
+
+#include <map>
+#include <set>
+
+bool LoggingInitialized = false;
+PmLogContext LogContext;
+
+namespace blink {
+
+typedef std::set<PalmServiceBridge*> ServicesSet;
+typedef std::map<Document*, ServicesSet*> ServicesSetMap;
+
+static ServicesSetMap* servicesByDocument()
+{
+    static ServicesSetMap map;
+    return &map;
+}
+
+int PalmServiceBridge::numHandlesForUrl(const char* appId)
+{
+    for (ServicesSetMap::iterator setIt = servicesByDocument()->begin(); setIt != servicesByDocument()->end(); ++setIt) {
+        if (!strcmp(appId, setIt->first->url().getString().utf8().data()))
+            return setIt->second->size();
+    }
+
+    return 0;
+}
+
+void PalmServiceBridge::handlesForUrl(const char* appId, std::list<PalmServiceBridge*>& outHandles)
+{
+    outHandles.clear();
+    for (ServicesSetMap::iterator setIt = servicesByDocument()->begin(); setIt != servicesByDocument()->end(); ++setIt) {
+        if (!strcmp(appId, setIt->first->url().getString().utf8().data())) {
+            ServicesSet* set = setIt->second;
+
+            for (ServicesSet::iterator s = set->begin(); s != set->end(); ++s)
+                outHandles.push_back(*s);
+
+            return;
+        }
+    }
+}
+
+static void addToServicesByDocument(Document* doc, PalmServiceBridge* svc)
+{
+    if (!doc || !svc)
+        return;
+
+    ServicesSet* set = 0;
+    ServicesSetMap::iterator it = servicesByDocument()->find(doc);
+    if (it == servicesByDocument()->end()) {
+        set = new ServicesSet();
+        (*servicesByDocument())[doc] = set;
+    } else
+        set = it->second;
+
+    set->insert(svc);
+}
+
+static void removeFromServicesByDocument(Document* doc, PalmServiceBridge* svc)
+{
+    if (!doc || !svc)
+        return;
+
+    ServicesSetMap::iterator it = servicesByDocument()->find(doc);
+    if (it == servicesByDocument()->end())
+        return;
+
+    ServicesSet* set = it->second;
+    if (!set)
+        return;
+
+    set->erase(svc);
+    if (!set->size()) {
+        // remove from the hash map
+        delete set;
+        servicesByDocument()->erase(it);
+    }
+}
+
+PalmServiceBridge::PalmServiceBridge(ExecutionContext* context, bool subscribe)
+    : ActiveDOMObject(context),
+      ActiveScriptWrappable(this),
+      m_canceled(false),
+      m_subscribed(subscribe),
+      m_inServiceCallback(false),
+      m_identifier(0),
+      m_isPrivileged(false)
+{
+    if (!LoggingInitialized) {
+        PmLogGetContext("QtWebEngineProcess", &LogContext);
+        LoggingInitialized = true;
+    }
+
+    addToServicesByDocument(document(), this);
+
+    Frame *frame = document()->frame();
+    Settings* settings = document()->settings();
+    if (settings != 0 && document()->page()->mainFrame() == frame) {
+        m_identifier = strdup(settings->luneosAppIdentifier().utf8().data());
+    }
+    else {
+        v8::Local<v8::Value> identifier;
+
+        identifier = document()->frame()->script().executeScriptInMainWorldAndReturnValue(ScriptSourceCode("PalmSystem && PalmSystem.getIdentifierForFrame(window.frameElement.id, window.frameElement.src)"));
+
+        // Failure is reported as a null string.
+        if (identifier.IsEmpty() || !identifier->IsString())
+            m_identifier = strdup("dummy_identifier 0");
+        else
+            m_identifier = strdup(toCoreString(v8::Handle<v8::String>::Cast(identifier)).utf8().data());
+    }
+
+    if (settings != 0)
+        m_isPrivileged = settings->luneosPriviledged();
+
+    DEBUG("PalmServiceBridge[%p]: created (subscribe %d identifier %s privileged %d)",
+          this, subscribe, m_identifier, m_isPrivileged);
+}
+
+bool PalmServiceBridge::init(Document* d, bool subscribe)
+{
+    m_subscribed = subscribe;
+
+    DEBUG("PalmServiceBridge[%p]: initialized (subscribe %d)", this, subscribe);
+
+    return true;
+}
+
+PalmServiceBridge::~PalmServiceBridge()
+{
+    DEBUG("PalmServiceBridge[%p]: destroying (identifier %s privileged %d subscribed %d)",
+          this, m_identifier, m_isPrivileged, m_subscribed);
+
+    cancel();
+
+    if (m_scriptState)
+        m_scriptState->clear();
+
+    if (getExecutionContext() && document())
+        removeFromServicesByDocument(document(), this);
+
+    if (m_identifier)
+        free(m_identifier);
+}
+
+void PalmServiceBridge::detachServices(Document* doc)
+{
+    ServicesSetMap::iterator it = servicesByDocument()->find(doc);
+    if (it == servicesByDocument()->end())
+        return;
+
+    ServicesSet* services = it->second;
+    servicesByDocument()->erase(it);
+
+    if (services) {
+        while (services->size()) {
+            ServicesSet::iterator sit = services->begin();
+            (*sit)->cancel();
+            services->erase(sit);
+        }
+        delete services;
+    }
+
+}
+
+void PalmServiceBridge::cancelServices(Document* doc)
+{
+    ServicesSetMap::iterator it = servicesByDocument()->find(doc);
+    if (it == servicesByDocument()->end())
+        return;
+
+    ServicesSet* services = it->second;
+
+    if (services) {
+        for (ServicesSet::iterator sit = services->begin(); sit != services->end(); ++sit) {
+            PalmServiceBridge* br = *sit;
+            br->cancel();
+        }
+    }
+}
+
+String PalmServiceBridge::version()
+{
+    return String("1.1");
+}
+
+int PalmServiceBridge::token()
+{
+    return (int)listenerToken;
+}
+
+int PalmServiceBridge::call(const String& uri, const String& payload, ExceptionState& exceptionState)
+{
+    DEBUG("PalmServiceBridge[%p]: calling on uri %s payload %s (identifier %s privileged %d subscribed %d)",
+          this, uri.utf8().data(), payload.utf8().data(), m_identifier, m_isPrivileged, m_subscribed);
+
+    LunaServiceManager::instance()->call(uri.utf8().data(), payload.utf8().data(), this, m_identifier, m_isPrivileged);
+    if (LSMESSAGE_TOKEN_INVALID == listenerToken) {
+        exceptionState.throwDOMException(EncodingError, "The LS2 call returned an invalid token.");
+        cancel();
+    }
+
+    return (int)listenerToken;
+}
+
+void PalmServiceBridge::serviceResponse(const char* body)
+{
+    if (m_canceled || !document() || !m_scriptState)
+        return;
+
+    if (!body)
+        body = "";
+
+    DEBUG("PalmServiceBridge[%p]: got service response %s (identifier %s privileged %d subscribed %d)",
+          this, body, m_identifier, m_isPrivileged, m_subscribed);
+
+    /* here we need to get the v8::Function associated with our v8 object */
+    ScriptState *pScriptState = m_scriptState->get();
+    v8::Isolate *isolateCurrent = pScriptState->isolate();
+    v8::HandleScope handleScope(isolateCurrent);
+    v8::Handle<v8::Value> cbValue = m_callbackScriptValue.v8ValueFor(pScriptState);
+    if (!cbValue.IsEmpty() && cbValue->IsFunction()) {
+        v8::Handle<v8::Function> cbFctV8 = cbValue.As<v8::Function>();
+        v8::Handle<v8::Value> argv[1];
+        argv[0] = v8::String::NewFromUtf8(isolateCurrent, body);
+
+        cbFctV8->Call(pScriptState->context()->Global(), 1, argv);
+    }
+
+   // document()->updateStyleIfNeeded();
+}
+
+void PalmServiceBridge::cancel()
+{
+    if (m_canceled)
+        return;
+
+    m_canceled = true;
+    if (listenerToken) {
+        DEBUG("PalmServiceBridge[%p]: canceling current call (identifier %s privileged %d subscribed %d)",
+            this, m_identifier, m_isPrivileged, m_subscribed);
+
+        LunaServiceManager::instance()->cancel(this);
+    }
+}
+
+void PalmServiceBridge::contextDestroyed()
+{
+    cancel();
+}
+
+bool PalmServiceBridge::hasPendingActivity() const
+{
+    return m_canceled == false && getExecutionContext() && !getExecutionContext()->activeDOMObjectsAreStopped();
+}
+
+Document* PalmServiceBridge::document() const
+{
+    ASSERT(getExecutionContext()->isDocument());
+    return static_cast<Document*>(getExecutionContext());
+}
+
+DEFINE_TRACE(PalmServiceBridge)
+{
+    ActiveDOMObject::trace(visitor);
+}
+} // namespace blink
diff --git a/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.h b/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.h
new file mode 100644
index 0000000000..46b6440318
--- /dev/null
+++ b/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.h
@@ -0,0 +1,92 @@
+#ifndef PalmServiceBridge_h
+#define PalmServiceBridge_h
+
+#include "core/dom/ActiveDOMObject.h"
+#include "core/dom/StringCallback.h"
+#include "bindings/core/v8/ScriptWrappable.h"
+#include "bindings/core/v8/V8Binding.h"
+#include "bindings/core/v8/ScriptValue.h"
+#include "bindings/modules/v8/ServiceCallback.h"
+#include "core/events/Event.h"
+#include "core/events/EventListener.h"
+#include "core/events/EventTarget.h"
+#include "LunaServiceMgr.h"
+
+// #include <heap/Strong.h>
+// #include <heap/StrongInlines.h>
+
+#include <glib.h>
+#include <list>
+
+
+namespace blink {
+
+class Document;
+
+
+class PalmServiceBridge : public GarbageCollectedFinalized<PalmServiceBridge>, 
+                          public LunaServiceManagerListener,
+                          public ActiveDOMObject,
+                          public ScriptWrappable, public ActiveScriptWrappable {
+    DEFINE_WRAPPERTYPEINFO();
+    USING_GARBAGE_COLLECTED_MIXIN(PalmServiceBridge)
+    WTF_MAKE_NONCOPYABLE(PalmServiceBridge);
+    public:
+        static PalmServiceBridge *create(ExecutionContext* context, bool subscribe = false)
+        {
+            return new PalmServiceBridge(context, subscribe);
+        }
+
+        bool init(Document*, bool subscribed = false);
+        ~PalmServiceBridge();
+
+        static int numHandlesForUrl(const char* appId);
+        static void handlesForUrl(const char* appId, std::list<PalmServiceBridge*>& outHandles);
+
+        virtual PalmServiceBridge* toPalmServiceBridge() { return this; }
+
+        static void detachServices(Document*);
+        static void cancelServices(Document*);
+
+        String version();
+
+        int token();
+
+        int call(const String& uri, const String& payload, ExceptionState&);
+        void cancel();
+
+        void setOnservicecallback(ScriptState *&cbState, ServiceCallback *cbValue) {
+            m_callbackScriptValue = ScriptValue::from(cbState, cbValue->v8Value(cbState->isolate()));
+            m_scriptState.reset(new ScriptStateProtectingContext(cbState));
+        }
+        ScriptWrappable *onservicecallback(ScriptState *cbState) const { return nullptr; }
+
+        // callback from LunaServiceManagerListener
+        virtual void serviceResponse(const char* body);
+
+        Document* document() const;
+
+        // ContextLifecycleObserver:
+        virtual void contextDestroyed();
+
+        // ActiveScriptWrappable.
+        bool hasPendingActivity() const final;
+
+    DECLARE_VIRTUAL_TRACE();
+
+    private:
+        ScriptValue m_callbackScriptValue;
+        std::unique_ptr<ScriptStateProtectingContext> m_scriptState;
+
+        bool m_canceled;
+        bool m_subscribed;
+        bool m_inServiceCallback;
+        char *m_identifier;
+        bool m_isPrivileged;
+
+        PalmServiceBridge(ExecutionContext*, bool);
+        PalmServiceBridge();
+};
+}
+
+#endif
diff --git a/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.idl b/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.idl
new file mode 100644
index 0000000000..3b431c379e
--- /dev/null
+++ b/chromium/third_party/WebKit/Source/modules/webos/PalmServiceBridge.idl
@@ -0,0 +1,14 @@
+callback ServiceCallback = void (DOMString message);
+
+[
+    Exposed=(Window,Worker),
+    ActiveScriptWrappable,
+    Constructor,
+    ConstructorCallWith=ExecutionContext
+] interface PalmServiceBridge {
+
+    [RaisesException] unsigned long call(DOMString method, DOMString url);
+    void cancel();
+
+    [CallWith=ScriptState] attribute ServiceCallback onservicecallback;
+};
diff --git a/chromium/third_party/WebKit/public/web/WebSettings.h b/chromium/third_party/WebKit/public/web/WebSettings.h
index f3bbc2322f..507184bfcf 100644
--- a/chromium/third_party/WebKit/public/web/WebSettings.h
+++ b/chromium/third_party/WebKit/public/web/WebSettings.h
@@ -204,6 +204,8 @@ class WebSettings {
   virtual void SetSavePreviousDocumentResources(
       SavePreviousDocumentResources) = 0;
   virtual void SetLocalStorageEnabled(bool) = 0;
+  virtual void SetLuneosAppIdentifier(const WebString&) = 0;
+  virtual void SetLuneosPriviledged(bool) = 0;
   virtual void SetMainFrameClipsContent(bool) = 0;
   virtual void SetMainFrameResizesAreOrientationChanges(bool) = 0;
   virtual void SetMaxTouchPoints(int) = 0;
@@ -217,6 +219,7 @@ class WebSettings {
   virtual void SetMockScrollbarsEnabled(bool) = 0;
   virtual void SetHideScrollbars(bool) = 0;
   virtual void SetOfflineWebApplicationCacheEnabled(bool) = 0;
+  virtual void SetPalmServiceBridgeEnabled(bool) = 0;
   virtual void SetPassiveEventListenerDefault(PassiveEventListenerDefault) = 0;
   virtual void SetPasswordEchoDurationInSeconds(double) = 0;
   virtual void SetPasswordEchoEnabled(bool) = 0;
